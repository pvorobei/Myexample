# Myexample

1.1. ИСТОРИЯ ТЕСТИРОВАНИЯ ПО
Первый блок модуля «Основные понятия контроля качества ПО» курса «Вве-
дение в тестирование ПО» рассматривает периоды развития тестирования, осно-
вываясь на этапах развития вычислительной техники и подходов к разработке
программного обеспечения.
На собеседовании при приеме на работу QA-инженерам часто задают вопрос:
«Что такое тестирование?». Отнеситесь к нему, как к приглашению начать беседу.
При ответе покажите разные подходы к определению тестирования. Начните с
официальных трактовок. В глоссарии международной компании ISTQB
(URL:https://glossary.istqb.org/), которая занимается вопросами развития сферы
тестирования ПО, представлено следующее определение: «Тестирование – Про-
цесс в рамках жизненного цикла разработки программного обеспечения, который
оценивает качество компонента или системы, а также связанных с ними рабочих
продуктов».
В отечественном ГОСТ Р 56920-2016 «Системная и программная инженерия.
Тестирование программного обеспечения. Часть 1» определение иное. «Тестиро-
вание (testing): Набор операций, проводимых для обеспечения выявления и/или
оценки свойств одного или более элементов тестирования. далее идет примеча-
ние, в котором описан процесс тестирования:
Действия тестирования могут включать в себя планирование, подготовку,
выполнение, создание отчетов и менеджмент, поскольку все они направлены на
тестирование».
При изучении курса будем придерживаться следующего определения: «Те-
стирование программного обеспечения – это процесс анализа программного сред-
ства и сопутствующей документации с целью выявления дефектов и повышения
качества продукта».
1.1.1. Тестирование в период 1950-1960 г.г.
Эра электронных вычислительных машин началась с методики Дж. фон Ней-
мана, описанной в 1945 году в рамках доклада «Первый проект» о вычислитель-
ной машине EDVAC. Именно от первых устройств, построенных на архитектуре
фон Неймана, отсчитываются поколения ЭВМ. Основным элементом этих вычис-
лительных машин были электронные лампы. Программы того времени были
написаны в машинных командах с привязкой к мнемоническому коду. Событием,
ознаменовавшим переход ко второму поколению компьютеров, было изобретениетранзистора: вычислительные машины на базе транзисторов возможно было со-
здавать промышленными методами. К компьютеру стало возможно подключать
различные периферийные устройства. Этот факт позволил использовать компью-
теры в различных областях науки и промышленности. Программы того времени
представляли собой монолитные программы. Они были собраны из программных
модулей, написанных, например, на ассемблере или фортране. В 50-60 годы про-
шлого века процесс тестирования был предельно формализован, отделён от про-
цесса непосредственной разработки ПО и «математизирован». Фактически тести-
рование представляло собой скорее отладку программ (debugging). Существовала
концепция исчерпывающего тестирования — проверки всех возможных путей
выполнения кода со всеми возможными входными данными. Однако очень скоро
было выяснено, что исчерпывающее тестирование невозможно, т. к. количество
возможных путей и входных данных очень велико, а также при таком подходе
сложно найти проблемы в документации.
Эдсгер Дейкстра отмечал, что «тестирование программ можно использовать
для того, чтобы показать наличие ошибок и никогда — для того, чтобы показать
их отсутствие!».
1.1.2. Тестирование в 1970-е годы
Появление больших интегральных схем позволили создать универсальный
процессор на одном кристалле. Развитие возможностей вычислительного обору-
дования привело к необходимости разработки программ для управления ЭВМ,
например на языке СИ, и поискам новых подходов к тестированию.
В 70-х годах фактически родились две фундаментальные идеи тестирования:
тестирование сначала рассматривалось как процесс доказательства работоспособ-
ности программы – позитивное тестирование, а затем – строго наоборот: как про-
цесс доказательства неработоспособности программы при вводе неправильных
данных – негативное тестирование. Позитивное и негативное тестирование – два
взаимодополняющих подхода к тестированию.
Негативные тест-кейсы пытаются вызвать сбои и отказы, но! корректно ра-
ботающее приложение выдерживает это испытание и продолжает работать верно.
Ожидаемым результатом негативных тест-кейсов является корректное поведение
приложения, а сами негативные тест-кейсы считаются пройденными успешно.
Таким образом, самое важное, что тестирование «приобрело» в 70-е годы:
– тестирование позволяет удостовериться, что программа соответствует тре-
бованиям;– тестирование позволяет определить условия, при которых программа ве-
дёт себя некорректно.
В этот период в основном проводят системное тестирование, применяемое к
скомпилированной программе. Проверяют качество разработанного программ-
ного продукта.
1.1.3. Тестирование в 1980-е годы
Появление персональных компьютеров в 80-х годах привело к появлению
новых программных продуктов для решения профессиональных задач грамотного
пользователя. Спектр разрабатываемых программных систем расширился. Для
создания качественного ПО стали применять новые технологии и подходы к раз-
работке.
В 80-х годах произошло ключевое изменение места тестирования в разра-
ботке ПО: вместо одной из финальных стадий создания проекта тестирование
применяют на протяжении всего цикла разработки. Такое решение позволило в
очень многих случаях не только быстро обнаруживать и устранять проблемы, но
даже предсказывать и предотвращать их появление. В это время появилась идея,
что тестирование – тоже управляемый процесс. Начинается переход от проверки
качества реализованного продукта к управлению качеством при разработке ПО.
В ходе тестирования надо проверить не только собранную программу, но и тре-
бования к ней, провести валидацию программного кода, проверить архитектуру.
В конце 80-х годов была разработана V–модель разработки ПО – через тестиро-
вание.
В этот же период времени отмечено развитие и формализация методологий
тестирования на основе методологий и практик разработок. К концу 80-х годов
тестирование проводят на разных уровнях: модульном, интеграционном, систем-
ном и приемочном, а также разными методами: черного, белого ящика. В эти годы
основное внимание специалистов уделялось оценке и измерению качества про-
граммного обеспечения.
1.1.4. Тестирование в 1990-е годы
В 90-х годах произошёл переход от тестирования как такового к всеобъем-
лющему процессу, который называется «обеспечение качества». Этот процесс
охватывает весь цикл разработки ПО и затрагивает процессы планирования, про-
ектирования, создания и выполнения тест-кейсов, поддержку имеющихся тест-кейсов и тестовых окружений. Тестирование вышло на качественно новый уро-
вень, который естественным образом привёл к дальнейшему развитию методоло-
гий, появлению достаточно мощных инструментов управления процессом тести-
рования и инструментальных средств автоматизации тестирования.
1.1.5. Тестирование в 2000-е годы
В нулевые годы нынешнего века развитие тестирования продолжалось в кон-
тексте поиска новых методологий, техник и подходов к обеспечению качества.
Серьёзное влияние на понимание тестирования оказало появление гибких мето-
дологий разработки и таких подходов, как «разработка под управлением тестиро-
ванием (test-driven development)». Автоматизация тестирования стала неотъемле-
мой частью большинства проектов. В 2004 году произошла крупная революция в
тестировании с появлением открытых инструментов автоматизации тестирования
Selenium. Затем появились инструменты для тестирования API с использованием
таких инструментов, как SOAP UI или Postman. В наше время изменился подход
к цели разработки программного обеспечения. Важно проверять не соответствие
программы требованиям, а её способность предоставить конечному пользователю
возможность эффективно решать свои задачи.
1.1.6. Тестирование в 2010-2020-е г годы
Процесс тестирования строго регламентирован. Качественный продукт со-
здают на основе соблюдения стандартов и ГОСТов. Они разработаны на основе
международных стандартов ИСО/МЭК и IEEE.
Госты серии 56920 под общим названием «Системная и программная инже-
нерия. Тестирование программного обеспечения» состоит из следующих частей:
– Часть 1. Понятия и определения;
– Часть 2. Процессы тестирования;
– Часть 3. Документация тестирования;
– Часть 4. Методики тестирования.
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013 Системная и программная
инженерия. Тестирование программного обеспечения. Часть 1. Понятия и опре-
деления.
ГОСТ Р 56921-2016/ISO/IEC/IEEE 29119-2:2013 Системная и программная
инженерия. Тестирование программного обеспечения. Часть 2. Процессы тести-
рования (ISO/IEC/IEEE 29119-2, Software and systems engineering – Software testing
– Part 2: Test processes).ГОСТ Р 56922-2016/ИСО/МЭК/ИИЭР 29119-3:2013 Системная и программ-
ная инженерия. Тестирование программного обеспечения. Часть 3. Документация
тестирования (ISO/IEC/IEEE 29119-3, Software and systems engineering – Software
testing – Part 3: Test documentation).
Список источников
1. Глоссарий ISTQB URL:https://glossary.istqb.org/.
2. Орлов С.А. Программная инженерия: учебник. – СПб.: Питер, 2016. – 640 с
3. Тестирование программного обеспечения. Базовый курс: практ. пособие. / С.
С. Куликов. — Минск: Четыре четверти, 2015. — 294 с.1.2. ОСНОВНЫЕ ПОНЯТИЯ КОНТРОЛЯ КАЧЕСТВА ПО
Важной характеристикой современных программных систем является их вы-
сокое качество. Для достижения высокого качества ПО уже недостаточно выде-
лять бюджет, необходимо внедрять процессы непрерывной верификации и вали-
дации, практики организации разработки и тестирования ПО, основываясь на ме-
тодах управления качеством, установленных международными и отечественными
стандартами.
В авторитетном словаре программной инженерии IEEE Std.610.12.-90 «IEEE
Standard Glossary of Software Engineering Terminology» зафиксировано два опре-
деления качества программного обеспечения:
Качество ПО – это степень соответствия системы, компонента или процесса
определенным требованиям.
Качество ПО – это степень соответствия системы, компонента или процесса
требованиям или фактическим ожиданиям заказчика, пользователя.
ГОСТ ИСО/МЭК 9126 «Информационная технология. Оценка программной
продукции. Характеристики качества и руководства по их применению» устанав-
ливает следующее определение:
Качество программного обеспечения (software quality) – это весь объем при-
знаков и характеристик программной продукции, который относится к ее способ-
ности удовлетворять установленным или предполагаемым потребностям.
В последнем определении появляются ключевые слова о характеристиках
программной продукции. Следовательно, необходимо понимание, какие характе-
ристики присущи программному обеспечению и как проводить их измерения,
чтобы понять, насколько они соответствуют требуемым.
1.2.1. Модели качества ПО
ГОСТ Р ИСО/МЭК 25010-2015. «Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения» предлагает использовать три модели качества систем и программ-
ных продуктов и соответствующие им характеристики качества.
Первая модель – модель качества при использовании. Определяет воздей-
ствие программного продукта на потребителя, которое зависит не только от каче-
ства программного обеспечения, но и от используемых аппаратных средств, ха-
рактеристик пользователей, задач и социальной среды.Вторая модель – модель качества продукта. Применяется не только для от-
дельного программного продукта, но и для компьютерной системы в целом, в со-
став которой входит программное обеспечение.
Третья модель – модель данных, описывает характеристики данных. В нашем
курсе рассмотрим первые две модели.
В модель качества при использовании входят пять характеристик:
1) эффективность;
2) производительность;
3) удовлетворенность запросов пользователей, связанная в первую очередь с
удобным интерфейсом;
4) свобода от риска, учитывается смягчение отрицательных последствий от
экономического риска, риска для здоровья и безопасности и других видов риска;
5) покрытие контекста, учитывается как полнота контекста, так и его гиб-
кость.
В модели качества продукта анализируется качество программного про-
дукта на основе восьми характеристик:
1) функциональная пригодность, которая отражает полноту, целесообраз-
ность и корректность функционала;
2) уровень производительности, включающий в себя временные характери-
стики, использование ресурсов и потенциальные возможности;
3) удобство использования, в первую очередь оценивается доступность и эс-
тетика пользовательского интерфейса, защищенность от ошибок пользователей,
управляемость и легкость обучения;
4) надежность, включающая в себя такие характеристики, как отказоустой-
чивость, восстанавливаемость, завершенность;
5) защищенность, в большинстве случаев подразумевается конфиденциаль-
ность, целостность, отслеживаемость и подлинность данных;
6) сопровождаемость, состоящая из модульности, возможности многократ-
ного использования, модифицируемости;
7) переносимость, адаптируемость, взаимозаменяемость различных компо-
нентов программного обеспечения,
8) совместимость с другими программными средствами.1.2.2. Матрица компромиссов
Достичь необходимо уровня качества по всем показателям одновременно не-
возможно. Матрица компромиссов показывает допустимые варианты сочетаемо-
сти характеристик. Сгруппируем характеристики в блоки по функциональности,
надежности, удобству использования, эффективности, портативности и удобству
сопровождения. Составим матрицу компромиссов (рис.1). Например, повторное
использование кода позволяет повысить тестируемость, позволяет быстро вно-
сить изменения и повысить удобство сопровождения. Также хорошо совместимы
характеристики интероперабельности и портативности.
Рисунок 1 – Матрица компромиссов
1.2.3. Контроль качества
Для достижения определенного уровня качества его контролируют. Поэтому
введем понятие контроля качества.
Контроль качества (quality control) – совокупность действий, проводимых
над продуктом в процессе разработки, для получения информации о его актуаль-
ном состоянии:
– готовности продукта к выпуску,
– соответствии зафиксированным требованиям,
– соответствии заявленному уровню качества продукта.Жизненный цикл программного продукта или системы состоит из несколь-
ких этапов: сбора и анализа требований, проектирования, разработки, тестирова-
ния и внедрения. Контроль качества проводят после этапа разработки (рис.2). Те-
стирование – один из видов деятельности контроля качества.
Рисунок 2 – Место контроля качества в ЖЦ ПО
Тестирование
Определение тестирования зафиксировано в отечественных гостах и между-
народных стандартах. В соответствии с ГОСТ 56920 «Системная и программная
инженерия. Тестирование программного обеспечения» тестирование – это про-
цесс, представляющий собой совокупность взаимосвязанных или взаимодейству-
ющих видов деятельности, преобразующих входы в выходы.
Процесс тестирования (test process) обеспечивает информацию о качестве
программного продукта, зачастую состоит из множества действий, сгруппирован-
ных в один или несколько подпроцессов тестирования.
Пример – процесс тестирования для определенного проекта может состоять
из множества подпроцессов: например, подпроцесса тестирования системы, под-
процесса планирования тестирования (часть большего процесса менеджмента те-
стирования) или подпроцесса статического тестирования.
Верификация и валидация
Верификация программного обеспечения – более общее понятие, чем тести-
рование. Целью верификации является достижение гарантии того, что верифици-
руемый объект соответствует требованиям, реализован без непредусмотренных
функций и удовлетворяет проектным спецификациям и стандартам. Процесс ве-
рификации включает в себя инспекции, тестирование кода, анализ результатов те-
стирования, формирование и анализ отчетов о проблемах. Таким образом, при-
нято считать, что процесс тестирования является составной частью процесса ве-
рификации.
Валидация программной системы – целью этого процесса является доказа-
тельство того, что в результате разработки системы мы достигли тех целей, кото-
рые планировали достичь благодаря ее использованию. Иными словами, валида-
ция – это проверка соответствия системы ожиданиям заказчика.Выбор методов верификации и валидации ПО зависит от выбранной органи-
зацией модели разработки (V-модель, каскадная, спиральная) и стандарта каче-
ства (например, ISO/IEC 25000 SQUARE). Предположим, что организация-разра-
ботчик выбрала модель разработки через тестирование. Каждый из рассмотрен-
ных процессов – тестирование, верификация или валидация – ответственен за
определенный уровень модели разработки (рис.3).
Тестирование отвечает на вопрос «Как это сделано?» или «Соответствует ли
поведение разработанной программы требованиям?».
Верификация – «Что сделано?» или «Соответствует ли разработанная си-
стема требованиям?».
Валидация – «Сделано ли то, что нужно?» или «Соответствует ли разрабо-
танная система ожиданиям?».
Рисунок 3 – Соответствие процессов тестирования уровням модели разработки
1.2.4. Обеспечение качества
Обеспечение качества (quality assurance) – систематический, планируемый
набор действий, необходимый для формирования приемлемого уровня уверенно-
сти в том, что процесс разработки и сопровождения программной системы соот-
ветствует установленным функциональным техническим требованиям, а также
организаторским требованиям соблюдения план-графика и бюджетных ограниче-
ний.
Главная цель – минимизировать стоимость гарантированного качества за
счет множества действий, выполняемых на различных этапах процесса разра-
ботки.Обеспечение качества – деятельность, осуществляемая на протяжении всего
жизненного цикла системы.
Для обеспечения требуемого уровня качества проводят определенные меро-
приятия:
1. Применение технических методов и средств анализа, проектирования, ко-
дирования и сопровождения.
2. Проведение технических проверок и аудитов на каждом шаге разработке.
3. Верификация и валидация.
4. Внедрение стандартов.
5. Контроль изменений.
6. Проведение измерений показателей качества и их оценка.
7. Формулирование отчетов по организации и разработке ПО.
1.2.5. Управление качеством
Следующим этапом процесса разработки конкурентоспособного ПО – это
управление качеством. В соответствии с ГОСТ Р ИСО 9000-2015 «Национальный
стандарт российской федерации системы менеджмента качества Основные поло-
жения и словарь (Quality management systems. Fundamentals and vocabulary)»
управление качеством – это часть менеджмента качества, направленная на выпол-
нение требований к качеству.
Программное обеспечение – это особый вид продукта, одной из важных ха-
рактеристик которого является его нематериальность. Для управления процессом
управления качеством такого продукта предусмотрены ГОСТы ИСО МЭК серии
25.000, в частности: ГОСТ Р ИСО/МЭК 25001-2017 «Информационные техноло-
гии. Системная и программная инженерия. Требования и оценка качества систем
и программного обеспечения (SQuaRE). Планирование и управление» (Infor-
mation technology. Systems and software engineering. Systems and software Quality
Requirements and Evaluation (SQuaRE). Planning and management). Настоящий
стандарт идентичен международному стандарту ИСО/МЭК 25001:2014 «Систем-
ная и программная инженерия. Требования и оценка качества систем и программ-
ного обеспечения (SQuaRE). Планирование и управление» (ISO/IEC 25001:2014
"Systems and software engineering - Systems and software Quality Requirements and
Evaluation (SQuaRE) - Planning and management", IDT).
Базис ГОСТов этой серии включает ГОСТы, регламентирующие планирова-
ние и управление, модели качества систем и программных продуктов, элементыпоказателей качества, процесс оценки, требования к качеству готового к исполь-
зованию программного продукта.
ГОСТ Р ИСО/МЭК 25001-2017 Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Планирование и управление.
ГОСТ Р ИСО/МЭК 25010-2015. Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Модели качества систем и программных продуктов.
ГОСТ Р ИСО/МЭК 25021-2014. Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Элементы показателя качества.
ГОСТ Р ИСО/МЭК 25040-2014. Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Процесс оценки.
ГОСТ Р ИСО/МЭК 25041-2014. Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Руководство по оценке для разработчиков, приобретате-
лей и независимых оценщиков.
ГОСТ Р ИСО/МЭК 25045-2015. Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Модуль оценки восстанавливаемости.
ГОСТ Р ИСО/МЭК 25051-2017 Информационные технологии. Системная и
программная инженерия. Требования и оценка качества систем и программного
обеспечения (SQuaRE). Требования к качеству готового к использованию про-
граммного продукта (RUSP) и инструкции по тестированию.
ГОСТ Р ИСО/МЭК 25066-2019 Системная и программная инженерия. Требо-
вания и оценка качества систем и программного обеспечения (SQuaRE). Общий
отраслевой формат (CIF) для удобства использования. Отчет об оценке.
Стратегической задачей в жизненном цикле современных информационных
систем стало обеспечение качества программных систем. Для их создания необ-
ходимо проводить тестирование, как один из процессов контроля качества, при-
менять методы по обеспечению качества и проводить планомерную работу на
уровне предприятия по управлению качеством (рис.4-5).Рисунок 4 – Соотношение уровней качества
Рисунок 5 – Задачи каждого уровня по реализации качества ПО
Предлагаю акцентировать внимание на основных определениях этой темы.
Тестирование – это проверка функционирования продукта, входит в методы
контроля качества ПО вместе с верификацией и валидацией.
Верификация – контролируемый и управляемый процесс, направленный на
демонстрацию наличия ошибок и условий их возникновения. Валидация показы-
вает соответствие разработанной системы требованиям пользователя и оценивает
качество разработанной системы с позиции конечного пользователя. Таким обра-
зом, контроль качества направлен на выявление и устранение дефектов при реа-
лизации системы.
Обеспечение качества ПО – это деятельность, осуществляемая на всем про-
тяжении жизненного цикла ПО. Она требует участия всех членов команды про-
екта и создает условия работы, которые помогут избегать дефектов. При разра-
ботке сложного ПО на первое место встает управление качеством и присущие ему
методы. Соблюдение таких правил, зафиксированных в отечественных и между-
народных стандартах, позволит создать конкурентоспособное программное обес-
печение.1.
2.
3.
4.
5.
6.
Список источников
Глоссарий ISTQB URL:https://glossary.istqb.org/.
Орлов С.А. Программная инженерия: учебник. – СПб.: Питер, 2016. – 640 с
ГОСТ Р ИСО/МЭК 25000-2021 Системная и программная инженерия. Требо-
вания и оценка качества систем и программных средств
Тестирование программного обеспечения. Базовый курс : практ. пособие. / С.
С. Куликов. – Минск: Четыре четверти, 2015. – 294 с.
Управление качеством программного обеспечения : учебник / Б.В. Черников.
– М. : ИД «ФОРУМ» : ИНФРА-М, 2022. – 240 с. – (Высшее образование:
Бакалавриат). – Режим доступа: http://znanium.com/catalog/product/1018037
Синицын, С. В. Верификация программного обеспечения : учебное пособие
С. В. Синицын, Н. Ю. Налютин. – Саратов : Профобразование, 2019. – 368 c.МОДЕЛИ РАЗРАБОТКИ ПО
С первых дней работы на проекте по разработке программного обеспечения
желательно понимать:
– по каким признакам выделяют приоритетные задачи;
– как формируют текущие задания;
– чем заняты коллеги по проекту.
Сотруднику необходимо видеть общую картину происходящего на проекте,
чтобы понять свое место в этом проекте и внести свой вклад в общее дело.
В зависимости от предметной области и сложности задач, стоящих перед ко-
мандой проекта, применяют разные модели разработки программного продукта.
Модель разработки ПО соответствует тому, какие стадии жизненного цикла
определяют процесс реализации ПО, и что происходит на каждой из них [1, 2].
Выбор модели разработки ПО также влияет на процесс тестирования, опре-
деляя выбор стратегии, расписание, необходимые ресурсы.
1. Итеративная модель
Как правило, итеративную модель (Iterative Model) применяют в следующих
случаях:
– требования к конечной системе заранее четко не определены;
– проект большой или очень большой;
– основная задача определена, но детали реализации могут эволюциониро-
вать с течением времени;
– поставлена задача с инновационным подходом, в успехе применения кото-
рого при разработке ПО заказчик не уверен.
Примером итерационной разработки может служить технология распознава-
ние голоса. Первые исследования и подготовка математического аппарата нача-
лись еще в конце двадцатого века, однако техническая и программно-аппаратная
реализация развивалась в течение последующих лет.
Рисунок 1 – Иллюстрация процесса разработки по итеративной модели2. Инкрементная модель
При разработке ПО на основе инкрементной модели (Incremental Model) про-
водят декомпозицию полных требований к разрабатываемой ПО с выделением
основных этапов работы над системой [1]. Имеют место несколько циклов разра-
ботки, каждый из которых разделен на более мелкие легко создаваемые модули.
Каждый модуль проходит через фазы определения требований, проектирования,
кодирования, внедрения и тестирования. Процедура разработки по инкрементной
модели предполагает выпуск на первом большом этапе продукта в базовой функ-
циональности, а затем уже последовательное добавление новых функций, так
называемых «инкрементов». Процедура продолжается до тех пор, пока не будет
создана полная система (рис.2).
Рисунок 2 – Иллюстрация процесса разработки по инкрементной модели
Как правило, инкрементную модель применяют в следующих случаях [3]:
– основные требования к системе четко определены и понятны. В то же время
некоторые детали могут дорабатываться с течением времени;
– требуется ранний вывод программного продукта на рынок;
– неопределенность бюджета на разработку ПС;
– разрабатываемое ПС обладает особенностями, использование которых свя-
зано с рисками разного рода.
В качестве примера инкрементной разработки рассмотрим разработку веб-
системы керамической мастерской. На первом этапе запланировано реализовать
веб-страницы с описанием мастер-классов и обратной связью. На втором этапе ‒
добавить страницу с отзывами и реализовать корзину покупателя с возможностью
проводить оплату покупок в онлайн-формате через специализированные сервисы.
На третьем этапе ‒ расширить витрину с ассортиментом интернет-магазина, внед-
рить на сайт интерактивного помощника, добавить всплывающие окна (pop-up) и
предусмотреть рассылку на электронные адреса зарегистрированных пользовате-
лей рекламной информации.Инкрементная и итеративная модели разработки могут быть совмещены
между собой (рис.3).
1-инкремент
Планирование и
разработка
Тестирование
Уточнение требований
Требования
Планирование и
разработка
2-инкремент
Тестирование
Уточнение требований
Планирование и
разработка
Развертывание
Развертывание
3-инкремент
Тестирование
Развертывание
Рисунок 3 – Сочетание итеративной и инкрементной моделей
Быстрый выпуск минимального продукта даёт возможность оперативно по-
лучать обратную связь от заказчика и пользователей. А значит, фокусироваться
на наиболее важных функциях ПС и улучшать их в соответствии с требованиями
рынка и пожеланиями клиента.
Таким образом, инкрементность означает подход, основанный на выполне-
нии задач в рамках «мини-проектов» (рис.2). Итеративность – последовательное
уточнение функционала разрабатываемого продукта (рис.1). Часто совместно с
этими понятиями используют понятие «эволюционность», под которым пони-
мают модель процесса по созданию ПО, напоминающую развитие по спирали.
3. Каскадная модель
Суть водопадной (каскадной) модели заключена в выделении четких после-
довательных этапов проекта. Каждый из этапов начинается с завершением преды-
дущего и заканчивается с началом следующего. Особенностью подхода является
то, что требования к проекту и его условия формулируются в самом начале. Хо-
рошо спланированный изначально проект обеспечивает точное выполнение всех
этапов его реализации. Как правило, для каждого этапа время указывается с запа-
сом, что позволяет избегать рисков в случае возникновения непредвиденных си-
туаций.Водопадная модель (waterfall model) позволяет получить положительный ре-
зультат только в проектах с четко и заранее определенными требованиями и спо-
собами их реализации [1]. Нет возможности сделать шаг назад, тестирование
начинается только после того, как разработка завершена или почти завершена.
Поэтому в настоящее время применяют модифицированную водопадную модель,
в которой используют принципы инкрементного и итеративного подходов к раз-
работке ПС (рис.4). Модель разработки стала более восприимчивой к измене-
ниям, которые могут возникать в ходе работы над проектом.
Подготовка
Сбор требований
Планирование
Оценка расписания
Моделирование
Анализ проектирования
Конструирование
Кодирование, тестирование
Развертывание
Внедрение, сопровождение
Рисунок 4 – Модифицированная водопадная модель
«Водопадная модель» подходит для разработки проектов в медицинской и
космической отрасли, где уже сформирована обширная база документов (СНиПов
и спецификаций), на основе которых можно написать требования к новому ПО, а
также при разработке сложных систем в банковской сфере.
4. V-модель
V-модель (разработка через тестирование) – это усовершенствованная кас-
кадная модель, в которой заказчик с командой программистов одновременно со-
ставляют требования к системе и описывают, как будут тестировать её на каждом
этапе (рис.5). Она представляет собой скорее набор стандартов в области проек-
тов, касающихся разработки новых продуктов. Так как тестирование проверяет
каждый этап разработки, количество ошибок в ПО сводится к минимуму.Сбор требований
Внедрение
Анализ требова-
ний
Системное и приемочное
тестирование
Интеграционное
тестирование
Архитектура
Модульное тести-
рование
Детализация
Кодирование
Рисунок 5 – V-модель: разработка через тестирование
5. Спиральная модель
Спиральная модель (Spiral Model) ориентирована на проекты, в которых име-
ются серьёзные риски. Процесс разработки представлен в виде спирали. Каждый
виток спирали – итерация. Виток спирали состоит из четырёх этапов: подготовка;
планирование; моделирование и конструирование; развертывание (рис.6). В
конце каждой итерации лица, принимающие решения, определяют целесообраз-
ность продолжения проекта. Характерной чертой является то, что на этапе ана-
лиза рисков создают прототипы, концепты и модели, которые призваны разре-
шить риск на ранней стадии. При разработке один и тот же набор процессов и фаз
может не повторяться от витка к витку. По мере продвижения по спирали все
больше внимания уделяется разработке продукта и меньше ‒ прототипам и кон-
цептам. Как правило, такую модель используют при реализации исследователь-
ских проектов или стартапов в случаях, когда заказчики еще не определились с
конечными требованиями [2].Рисунок 6 – Спиральная модель
Рассмотрим применение спиральной модели на примере разработки мобиль-
ного приложения в области розничной торговли. Программный продукт должен
взаимодействовать по Bluetooth с определенным в техническом задании оборудо-
ванием, в частности, со считывателями банковских карт, различными типами
принтеров и сканерами штрих-кодов. На начальном этапе разработчики не знают,
возможна ли требуемая реализация на мобильной платформе. Поэтому на уровне
прототипов и концептов необходимо выяснить принципиальную возможность
взаимодействия с оборудованием и существующие ограничения. Затем на встрече
с заказчиками проводят демонстрацию полученного результата, обсуждают об-
ходные пути для того, что не удалось реализовать. После выполнения базовых
первичных требований на следующих витках спирали заказчики, например, могут
проявить интерес к созданию в дополнение к мобильному приложению десктоп-
ной версии ПС.Список источников
1. Орлов С.А. Программная инженерия: учебник. – СПб.: Питер, 2016. – 640 с.
2. Турнецкая Е.Л. Методологии и технологии проектирования информацион-
ных систем: : учебно-методическое пособие / А. В. Аграновский, В. С. Пав-
лов, Е. Л. Турнецкая ; С.-Петерб. гос. ун-т аэрокосм. приборостроения.-
Санкт-Петербург : Изд-во ГУАП, 2021. - 111 с.
3. Турнецкая, Е. Л. Программная инженерия. Интеграционный подход к разра-
ботке / Е. Л. Турнецкая, А. В. Аграновский. — Санкт-Петербург : Лань, 2023.
— 216 с. — ISBN 978-5-507-46898-0. — Текст : электронный // Лань : элек-
тронно-библиотечная система. — URL: https://e.lanbook.com/book/352307
(дата обращения: 17.07.2024). — Режим доступа: для авториз. пользователей.ПРАКТИКИ ИНДУСТРИАЛЬНОЙ РАЗРАБОТКИ ПРОГРАММ-
НОГО ОБЕСПЕЧЕНИЯ
Методология разработки ПО кроме модели включает набор методов по
управлению организацией самого процесса разработки [1]. Таким образом, мето-
дология конкретизирует процесс разработки ПО в рамках выбранной модели.
Принято различать «тяжеловесные» и «лёгкие» методологии разработки ПО.
К первой группе относят методологии, построенные, например, на водопадной
модели, где все этапы проекта определены. Такие методологии применяют при
работе над большими или средними проектами. При организации разработки про-
ектов с быстро меняющимися требованиями эффективнее применять набор прак-
тик, которые получили название «динамические», «облегченные» или «agile»-ме-
тодологии
1. Принципы Agile
Основополагающий документ Agile Manifesto содержит четыре основные
идеи и двенадцать принципов (рис.1).
Рисунок 1 – Основные принципы Agile
Основные идеи Agile Manifesto [2]:
1. Люди и взаимодействие важнее процессов и инструментов.
2. Работающий продукт важнее исчерпывающей документации.
3. Сотрудничество с заказчиком важнее согласования условий контракта.
4. Готовность к изменениям важнее следования первоначальному плану.Выделим основные принципы Agile Manifesto:
А. Работающий продукт следует выпускать как можно чаще, с периодично-
стью от пары недель до пары месяцев.
Б. Изменения в требования вносят до завершающего этапа разработки.
В. Постоянное внимание к техническому совершенству и качеству проекти-
рования повышает гибкость проекта.
Г. При разработке придерживаются принципа минимализма. Выбирают са-
мое простое решение для реализации.
Д. Постоянный анализ выполненных задач и обсуждения по улучшению про-
цессов разработки внутри команды.
При сравнении подходов к разработке используют критерий получения ре-
зультата для заказчика и команды разработки.
При организации разработки на основе каскадной модели подводят итоги по-
сле внедрения программного продукта (рис.2). Если выбраны гибкие практики, то
результат можно оценить после каждой итерации (рис.2).
Рисунок 2 – Сравнение водопадной модели и agile-практик
2. Фреймворк SCRUM
Рейтинг agile-практик, применяемых при управлении разработкой программ-
ного продукта, показывает, что лидером выступает гибкий фреймворк SCRUM
(рис.3) [6].Lean Startup; 1%
Iterative
Don’t
Now;
3%
XP; 1%
Development; 4%
KANBAN; 7%
SCRUM/Hybrid;
8%
SCRUM; 58%
Other/Hybrid; 9%
SCRUMBAN;
10%
Рисунок 3 – Рейтинг agile-практик
При организации процесса разработки по SCRUM выделяют роли участни-
ков, артефакты и процессы (табл.1).
Таблица 1 – Роли, артефакты и процессы в SCRUM
РолиАртефактыПроцессы
Команда
Scrum-мастер
Владелец продукта
СтейкхолдерыЖурнал (бэклог) продукта
Журнал (бэклог) спринта
Инкремент продуктаСпринт
Планирование спринта
Scrum-митинг
Обзор спринта
Ретроспектива
В первую очередь, необходима команда универсальных разработчиков
(Delivery Team), которые могут взаимозаменять друг друга по профессиональным
компетенциям на любом этапе разработки [1, 3, 6].
Как правило, в состав команды входит от семи до десяти высокопрофессио-
нальных специалистов, которые взаимодействуют со SCRUM-мастером и вла-
дельцем продукта (Product Owner).
SCRUM-мастер организует и обеспечивает бизнес-процессы, занимается ре-
шением бытовых проблем, проводит общие собрания (митинги), мотивирует со-
трудников и следит за тем, чтоб на каждом этапе соблюдался SCRUM-подход.Владелец продукта – лицо, ответственное за разработку. Это или заказчик,
или официальный представитель, который осуществляет связь с заинтересован-
ными лицами. Он ставит цель по разработке ПС перед разработчиками и следит
за этапами разработки.
К заинтересованным лицам (стейкхолдерам, заказчикам) принято относить
тех, кто инвестирует в результат проекта. Заинтересованные лица рассматривают
ключевые решения, а также предоставляют обратную связь после каждого инкре-
мента.
SCRUM-методика делит все рабочие процессы на одинаковые спринты –
определенные периоды (неделя, месяц, квартал и так далее) в зависимости от со-
става команды и от проекта. Перед началом каждого периода (спринта) формиру-
ются задачи, а когда период заканчивается, обсуждают результаты и артефакты,
после чего можно начинать следующий спринт (рис.4).
Рисунок 4 – Спринт в SCRUM
Планирование спринта осуществляют на общей встрече участников SCRUM-
команды. По его результатам формируют список задач, которые необходимо ре-
шить в течение одного спринта, и перечень работ, которые должны быть для этого
проделаны.
SCRUM-митинги – 15-минутные ежедневные совещания разработчиков, на
которых обсуждают возникающие в процессе разработки вопросы, а также уточ-
няются планы на ближайшие 24 часа. Эти совещания ведет SCRUM-мастер.
Обзор спринта – встреча, которая проводится по окончании каждого спринта
для обсуждения его результатов внутри коллектива разработчиков.Ретроспектива спринта – обсуждение улучшения или расширения функцио-
нальных и нефункциональных возможностей программной системы. Ретроспек-
тива происходит после обзора спринта перед планированием следующего
спринта.
SCRUM-разработка включает в себя три важных документа, называемых ар-
тефактами:
1. Журнал продукта (бэклог продукта, Product Backlog) – список требований
к продукту или задач, которые реализуют в процессе разработки. Такой список
формируют на основе анализа требований заказчика, собранных в виде пользова-
тельских историй (user story).
2. Журнал спринта (бэклог спринта, Sprint Backlog) – часть требований жур-
нала продукта, выбранная для выполнения при планировании данного спринта, а
также выработанный план работ.
3. Инкремент – это сумма всех выполненных требований журнала продукта,
реализованных во время текущего спринта и всех предыдущих спринтов. Это
функционал, который демонстрируется стейкхолдерам по итогам спринта. По-
этому при завершении спринта производится тестирование новых функций или
улучшений продукта.
Принято считать, что каждый инкремент должен быть пригоден к эксплуата-
ции, хотя решение о запуске данного инкремента в эксплуатацию принимает вла-
делец продукта, и оно не обязательно должно быть положительным после каж-
дого спринта.
Цель спринта описывают аббревиатурой SMART: Specific (конкретный),
Measurable (измеримый), Achievable (достижимый), Relevant (значимый), Time
bound (ограниченный во времени). Каждая буква аббревиатуры SMART означает
критерий эффективности поставленных целей.
SCRUM подходит для компаний с небольшой командой разработчиков,
например, стартапов, внутри которых отсутствует жесткая административная
иерархия, с наличием постоянного контакта между клиентом и командой для опе-
ративного внесения правок в требования или модификации ПО, в условиях огра-
ниченного бюджета и строгих временных рамок по завершению работы над про-
ектом.3. Набор практик KANBAN
Набор практик KANBAN основан на балансе: работу по разработке про-
граммной системы распределяют среди сотрудников примерно одинаково. Про-
ект разделяют на стадии разработки. Основным критерием эффективности реали-
зации проекта является скорость или время прохождения задачи через все стадии.
Чтобы использовать KANBAN, команда должна знать принципы, по кото-
рым работает [4, 6]:
1. Возможность изменять ход производства/разработки. При возникновении
задачи, имеющей более высокий приоритет, чем находящаяся в разработке, вни-
мание сотрудников переключается на ее выполнение.
2. Ограничение по количеству одновременно выполняемых задач на каждом
этапе разработки. Таким образом, регулируется нагрузка на сотрудников.
3. Наглядное отображение процесса разработки ПС средствами сторимап-
пинга.
4. Постоянное улучшение программного продукта и процесса его разработки.
5. Время цикла. Время выполнения каждой задачи обязательно фиксируют и
оценивают. Уменьшение времени цикла работы над выполнением конкретной за-
дачи относят к приоритетным вопросам.
Для контроля и регулирования времени выполнения задач разработчики про-
водят небольшие совещания – каденции (петли обратной связи).
Каденция – это регулярное совещание, которые задают особый ритм про-
цессу разработки. В зависимости от задач, которые требуют решения их проводят
раз в день, в неделю или раз в месяц.
Для визуализации процесса работы над проектом применяют канбан-доски.
На каждую задачу назначают исполнителя, срок выполнения и необходимые ар-
тефакты. При решении задача перемещается по доске от точки принятия обяза-
тельств «Сделать» (ToDo) до точки отдачи обязательств «Сделано» (Done).
(рис.5).Рисунок 5 – Доска KANBAN
В каждой графе видны задачи, которые находятся на одной стадии решении.
Work in progress – работа, находящаяся в системе от точки принятия обязательств
до точки отдачи обязательств.
Цель – уменьшение количества «выполняющейся в данный момент работы»
Если команда видит проблемы на каком-то этапе, то менее загруженные по ра-
ботке сотрудники приходят на помощь коллеге.
Канбан-метод может помочь в определенных целях:
‒ достичь гибкой системы планирования;
‒ оптимизировать временные затраты;
‒ выстроить прозрачность, доверительные отношения между клиентами и ко-
мандами;
‒ оперативно решать проблемы по выстраиванию процесса.
Сравнение практик между собой показано в табл.2. Основные критерии срав-
нения: по количеству обязательных совещаний, по наличию точки отсчета по вы-
полнению каждой задачи проекта, по типу команды, возможности внесения изме-
нений, деления на роли внутри команды [5-6].
Таблица 2 – Сравнение Kanban и Scrum
Kanban
Нет совещаний
Фиксация точки начала работы
Могут работать узкопрофильные
команды
Последовательные и плавные
перемены
В команде нет разделения на роли
Scrum
Есть совещания
Точку начала работы не фиксируют
Только кроссфункциональная команда
Кардинальные перемены
В команде есть разделение на ролиФреймворк SCRUM подходит для изменчивого рынка, новых разработок и
тесного взаимодействия разработки со стейкхолдерами.
Набор практик KANBAN не требует радикальных изменений в работе орга-
низации, но вынуждает их сменить приоритеты и акцентировать внимание на ре-
шении задач.
4. Визуализация процесса разработки
Важной составляющей рассмотренных подходов к руководству проекта яв-
ляется визуализация процесса разработки. Рассмотрим пример доски проекта
(рис.6) в облачной системе Kaiten (https://kaiten.ru/).
Рисунок 6 – Доска проекта в облачной системе Kaiten
В каждую группу KANBAN-доски попадают карточки с описанием задач
(рис.6). Таким образом, группы превращаются в некие to-do-списки общего назна-
чения. Карточки повышают наглядность отображаемой информации и упрощают
ориентирование команды в большом потоке задач.
К тому же, в цифровом виде распределение по карточкам дает возможность
задать дополнительные атрибуты (рис.7). Например, показать, кто ответственен
за выполнение задачи, определить, когда она должна быть сделана, или оставить
заметку с дополнительной информацией (рис.8).Рисунок 7 4– Атрибуты карточки проекта
Рисунок 85 – Карточка проекта с атрибутами
5. Ретроспектива появления практик и моделей разработки ПО
Рассмотрим ретроспективу появления практик и моделей разработки ПО. В
ней не показаны корпоративные методологии, например, Rational Unified Process.
Внимание сосредоточено на классических моделях: водопадной, спиральной и на
Agile-практиках (рис.9). Каждая модель и практика появляется как решение про-
блем разработки качественного ПО. В настоящее время активно развивается
DevOps-практика.Рисунок 9 – Ретроспектива появления практик и моделей ПО
DevOps позиционируется как Agile-подход для устранения организационных
и временных барьеров между командами разработчиков и других участников жиз-
ненного цикла ПО (тестировщиками, администраторами, техподдержкой), чтобы
они могли быстрее и надежнее собирать, тестировать и выпускать релизы про-
граммных продуктов.
DevOps в целом – направление, специалисты которого обеспечивают процесс
автоматизации и выстраивают соответствующую культуру и свод практик внутри
компании. Различают разные сферы применения этого подхода при разработке ПО:
‒ TechOps – приближенная к области системного администрирования;
‒ DataOps – с фокусировкой на анализ данных;
‒ CloudOps – связанная с облачными решениями;
‒ SRE (Site Reliability Engineering) – с фокусом на обеспечение бесперебой-
ной работы высоконагруженных сервисов;
‒ DevSecOps – направленная на обеспечение безопасности в рамках пайплай-
нов автоматизации.
Список источников
1. Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. СПб: Питер, 2020. С.640
2. Agile Manifesto. URL: https://agilemanifesto.org/iso/ru/manifesto.html
3. Практики Kanban. URL: https://kanban.university/
4. Официальный сайт SCRUM. URL: https://scrumguides.org/scrum-guide.html
5. Турнецкая Е.Л. Методологии и технологии проектирования информацион-
ных систем : учебно-методическое пособие / А. В. Аграновский, В. С. Пав-
лов, Е. Л. Турнецкая ; С.-Петерб. гос. ун-т аэрокосм. приборостроения. -
Санкт-Петербург : Изд-во ГУАП, 2021. - 111 с.6. Турнецкая, Е. Л. Программная инженерия. Интеграционный подход к разра-
ботке / Е. Л. Турнецкая, А. В. Аграновский. — Санкт-Петербург : Лань, 2023.
— 216 с. — ISBN 978-5-507-46898-0. — Текст : электронный // Лань : элек-
тронно-библиотечная система. — URL: https://e.lanbook.com/book/352307
(дата обращения: 17.07.2024). — Режим доступа: для авториз. Пользователей3. МОДЕЛИ, УРОВНИ И ТИПЫ ТЕСТИРОВАНИЯ
Тестирование программного обеспечения – процесс анализа программного
средства и сопутствующей документации с целью выявления дефектов и повыше-
ния качества продукта [1].
Основными целями тестирования являются [2]:
‒ обнаружение дефектов в элементе тестирования до его передачи в эксплу-
атацию;
‒ оценка того, были ли дефекты корректно устранены без неблагоприятных
побочных эффектов;
‒ оценка корректной реализации изменений без неблагоприятных побочных
эффектов и др.
‒ предоставление информации о качестве элемента тестирования и любых
остаточных рисках относительно того, до какой степени элемент тестирования
был проверен;
‒ оценка выполнения требований (то есть нормативных, проектных, договор-
ных и т.д.);
‒ оценка того, оправдал ли продукт надежды заинтересованной стороны;
‒ предоставление информации о качествах продукта;
‒ смягчение рисков получения продукта низкого качества заинтересован-
ными сторонами;
‒ предоставление информации для действий менеджмента рисков;
Тестирование выполняется, чтобы достигнуть одной и большего числа це-
лей.
ГОСТ Р 56920-2016 «Системная и программная инженерия. Тестирование
программного обеспечения. Часть 2. Процессы тестирования» указывает, что
цели тестирования индивидуальны для конкретного подпроцесса [3].
Под подпроцессами тестирования (test sub-process) понимают процессы
менеджмента тестирования и процессы динамического (и статического) тестиро-
вания, используемые для выполнения определенного уровня тестирования
(например, тестирование системы, приемочные испытания) или его определен-
ного типа (например, тестирование удобства использования, тестирование произ-
водительности) обычно в контексте полного процесса тестирования.Например, при тестировании готового коммерческого продукта тестирова-
ние для оценки того, что дефекты устранены, не может быть указано в качестве
цели, поскольку ожидается, что поставщик ранее завершил тестирование по по-
иску и устранению дефектов. Здесь уместно использовать подпроцесс приемоч-
ных испытаний для достижения другой цели тестирования – удостовериться в
том, оправдал ли продукт надежды заинтересованной стороны.
В стандарте ГОСТ Р 56920-2016 «Системная и программная инженерия. Те-
стирование программного обеспечения. Часть 1. Понятия и определения» [2] ис-
пользуется трехуровневая модель процесса тестирования, подробно описанная в
ИСО/МЭК/ИИЭР 29119-2 (рис.1). Модель процесса начинается с организацион-
ного управления спецификациями тестирования высокого уровня. Средний уро-
вень показывает менеджмент тестирования (менеджмент тестирования проекта,
менеджмент фазы тестирования, менеджмент типа тестирования). Нижний уро-
вень определяет множество процессов тестирования, используемых в динамиче-
ском тестировании. Под динамическим тестированием (dynamic testing) пони-
мают тестирование, при котором требуется выполнение элемента тестирования с
запуском кода на исполнение.
Рисунок 1 – Трехуровневая модель процесса тестированияУровни модели процесса тестирования содержат разное число процессов те-
стирования (рис.2).
Рисунок 2 – Многоуровневая модель, в которой показаны все процессы тестирования
Следует отметить, что процесс тестирования зависит от выбранной на про-
екте методологии или практики разработки ПО, с которыми соотносят выбор
стратегии тестирования, расписание тестовых мероприятий, необходимые ре-
сурсы и т.д.
Взаимосвязи между общим процессом тестирования, общими подпроцес-
сами тестирования, уровнями/фазами тестирования и типами тестирования более
подробно показаны на рис.3. Рисунок показывает реализацию общих подпроцес-
сов тестирования на определенных уровнях тестирования и в соответствии с ти-
пом тестирования.Рисунок 3 – Взаимосвязи между общим процессом тестирования,
уровнями тестирования и типами тестирования
Общий подпроцесс тестирования может быть реализован:
‒ на уровне или фазе тестирования. То есть каждый уровень тестирования
представляет собой определенное приложение общего подпроцесса тестирования
(например, фаза покомпонентного тестирования, уровень приемочного испыта-
ния);
‒ как тестирование определенного типа. То есть каждый тип тестирования
представляет собой определенное приложение общего подпроцесса тестирования
(например, тестирование производительности, тестирование удобства использо-
вания).
Подпроцесс тестирования, соответствующий уровню тестирования, может
включать в себя больше одного подпроцесса разного типа тестирования (напри-
мер, функциональный и тестирование производительности являются частями те-
стирования системы).3. ЖИЗНЕННЫЙ ЦИКЛ ТЕСТИРОВАНИЯ
3.1. Задачи и принципы тестирования
Тестирование программного обеспечения – процесс анализа программного
средства и сопутствующей документации с целью выявления дефектов и повыше-
ния качества продукта. Необходимо акцентировать внимание на том, что итог
процесса тестирования – повышение качества разрабатываемого программного
продукта.
Поэтому задачами тестирования являются:
– Проверка, все ли указанные требования выполнены: у каждого продукта
есть техническое задание (ТЗ). Тестировщики должны проверить, что все требо-
вания из ТЗ не только реализованы, но и работают правильно.
– Создание уверенности в уровне качества объекта тестирования.
– Задача предотвращения дефектов достигается поиском проблем на ранних
этапах разработки ПО, например при тестировании требований и возможности
реализации технического задания.
– Задача обнаружения инцидентов – это задача поиска отклонения поведения
тестируемого ПО от поведения, прописанного в ТЗ.
– Предоставление заинтересованным лицам достаточной информации, поз-
воляющей им принимать обоснованные решения. Тестировщики могут показать
текущее состояние продукта, выраженное в количестве багов, например, путем
оформления баг-репортов.
– Задача снижения уровня риска ненадлежащего качества программного
обеспечения позволяет сократить траты на исправление ошибок в релизной вер-
сии и снижение репутационных рисков компании-разработчика.
Принципы тестирования:
1. Тестирование демонстрирует наличие ошибки. Тестирование может вы-
явить тот момент, что ошибки присутствуют, но не может доказать в полной мере,
что дефектов нет.
2. Исчерпывающее тестирование недостижимо. Полное тестирование с ис-
пользованием всех комбинаций входных вводов и предусловий физически невы-
полнимо, за исключением тривиальных случаев.
3. Раннее тестирование. Это принцип говорит о том, что чем раньше вы-
явится та или иная проблема – тем меньше средств и трудозатрат потребуется для
её устранения.4. Принцип скопления или кластеризация дефектов. Как правило, большая
часть ошибок, обнаруженных при тестировании, содержится в небольшом коли-
честве модулей. Ошибки скапливаются в определённых местах, например, там,
где код наиболее сложный или некорректно написан. Если в каком-то модуле
нашлось несколько инцидентов – это сигнал к тому, чтобы ещё внимательнее про-
тестировать его с особой тщательностью на наличие скрытых дефектов.
5. Парадокс пестицида. Если одни и те же тесты будут прогоняться много
раз, в конечном счете этот набор тестовых сценариев больше не будет находить
новых дефектов.
6. Тестирование зависит от контекста. Тестирование выполняется по-раз-
ному в зависимости от контекста. По каким характеристикам различать контекст:
– по типу продукта – web, desktop, мобильное приложение, сервис и др.;
– по цели продукта – обеспечение безопасности, Game, продажа товаров и
др.;
– по проектной команде – специализация, количество человек, опыт и т.д.;
– по доступным инструментам – что присутствует на проекте, для успешной
реализации;
– по срокам – как построен рабочий процесс, как часто выходят релизы,
время между ними на подготовку;
– по ожидаемому уровню качества – чем выше требования, тем тщательнее
нужно тестировать.
7. Заблуждение об отсутствии ошибок. Обнаружение и исправление не помо-
гут, если созданная система не подходит пользователю и не удовлетворяет его
ожиданиям и потребностям.
3.2. Пирамида тестирования
Для визуализации по уровням тестирования используют пирамиду тестиро-
вания. С ее помощью проводят группировку тестов по уровню детализации и их
назначению (рис.1). Эту абстракцию придумал Майк Кон и описал в книге
«SCRUM: гибкая разработка ПО».Рисунок 1 – Пирамида тестирования
В основании пирамиды – юнит-тесты или модульные тесты. Они проверяют,
что отдельные изолированные части кода работают правильно. Тестируется один
класс, метод или функция. Если они связаны с другими модулями, то их связь
заменятся программной заглушкой, эмулирующей их поведение. На этом уровне
выполняют наибольшее количество тестов. Выполняются они быстрее, часто «па-
кетами», и требуют меньше усилий. Модули собирают в компоненты. Иногда, мо-
дульное тестирование называют компонентным
Интеграционные тесты проверяют, как несколько сервисов взаимосвязаны
друг с другом. Интеграционные тесты проверяют связь с базой данных, исполь-
зуют сеть для вызова другого компонента или модуля, используют базу данных,
читают/записывают файлы.
После завершения юнит- и интеграционного тестирования наступает этап си-
стемного тестирования. Проверка всех элементов, составляющих программную
систему, на соответствие требованиям.Последний уровень – проверка, выполнены ли требования конечных пользо-
вателей. Если приемочное тестирование успешно завершено, продукт идет на до-
ставку, и считается, что продукт будет нормально работать в пользовательском
окружении.
Для каждого уровня тестирования QA-инженер должен написать тесты, про-
веряющие работоспособность компонентов конкретного уровня.
Пирамиду тестирования представляют и в других видах. Например, на ри-
сунке 2 кроме известных нам юнит-тестов на модульном уровне и интеграцион-
ных тестов выделены уровни E2E тесты и UI тесты.
Рисунок 2 – Типы тестов и уровни тестирования
E2E-тесты применяют для того, чтобы удостоверится, что программа отве-
чает ТЗ от начала до конца. Основная цель – убедиться, что программа работает
корректно, и если у нее есть зависимые системы, то данные передаются кор-
ректно. Обычно для такого вида тестирования разрабатывают сценарий, который
максимально приближен к реальной эксплуатации программы. Например, в сце-
нарий закладываются подключения к базе данных, получение данных из БД, от-
правка данных в БД, взаимодействие с сетью и многое другое. Такие тесты может
выполнять робот-помощник, который эмулирует работу пользователя приложе-
ния.UI-тестирование – этап комплексного тестирования программного обеспече-
ния, на этом этапе QA-специалисты проверяют качество всех компонентов интер-
фейса. UI-тестирование помогает убедиться, что функции приложения отрабаты-
вают на достижение целей и удобны для пользователей. UI-тестирование улуч-
шает качество программного обеспечения и обеспечивает удобство приложения
для пользователей.
В идеальной пирамиде тестирования (рис.3) добавлен уровень тестирования
API. Уровень показывает сложность разрабатываемых в настоящее время про-
граммных систем. Они могут состоять из микросервисов или использовать сер-
вис-ориентированную архитектуру и предоставлять программный интерфейс для
взаимосвязи между частями приложения.
Рисунок 3 – Идеальная пирамида тестирования
Обратите внимание, что чем выше в пирамиде тестирования расположены
тесты, тем больше времени потребуется на их реализацию, они будут более тру-
доемки по сравнению с тестами на более низких уровнях.
3.3. Жизненный цикл тестирования
Жизненный цикл тестирования (Software Testing Lifecycle, STLC) – это по-
следовательность действий, проводимых в процессе тестирования, с помощью ко-
торых гарантируется качество программного обеспечения и его соответствие тре-
бованиям. Тестирование состоит из серии действий, выполняемых по выбранной
тестировщиком методике, с целью гарантирования качества продукта.Процесс тестирования – это итеративный процесс, который состоит из сле-
дующих этапов (рис.4):
1. Анализ (оценка) требований
2. Планирование тестирования
3. Этап создания тест-кейсов
4. Настройка тестового окружения
5. Выполнение тестов
6. Завершение тестирования
Рисунок 4 – Этапы жизненного цикла тестирования
Рассмотрим этапы, выделяя для каждого присущие ему артефакты.
На этапе анализа требований QA-команда оценивает требования с точки
зрения тестирования, составляют матрицу отслеживания требований. Для этого
QA-команда может обращаться к представителям заказчика. Требования могут
быть «функциональными» или «нефункциональными», то есть касаться или не
касаться функциональной составляющей софта. Также на этом этапе проводится
оценка возможности применения автоматизированного тестирования, опреде-
ляют тестовое окружение.
Результаты этапа:
– Матрица отслеживания требований
– Отчет о возможности автоматизации
На этапе планирования руководитель QA-команды определяет стратегию
тестирования и оценивает трудозатраты. Также оцениваются ресурсы, тестовое
окружение, возможные ограничения и график тестирования, выбирают инстру-
менты тестирования. На этом же этапе создают план тестирования.Результаты этапа:
– Документ со стратегией тестирования
– Документ с оценкой ресурсов
На этапе создания тест-кейсов происходит подготовка тестовых данных и
создаются тест-кейсы.
Результаты этапа:
– Тест-кейсы и/или скрипты
– Тестовые данные
На этапе настройки тестового окружения проходит конфигурирование
программно-аппаратной среды тестирования. Это один из критически важных ас-
пектов процесса, он может проходить параллельно этапу создания тест-кейсов.
QA-команда может и не включаться в этот процесс, если тестовое окружение ей
обеспечит команда разработки.
Результаты этапа:
– Настроенное окружение для проведения тестирования
– Результаты дымовое тестирования окружения
На этапе выполнения тестов QA-инженер проводит тестирование, выпол-
няя подготовленные тест-кейсы. Процесс состоит из выполнения тестовых скрип-
тов. Далее идет создание баг-репортов. Если найдены дефекты, информация о них
передается команде разработки для исправления и повторного тестирования QA-
командой. Проводят обновление матрицы отслеживания требований.
Результаты этапа:
– Модифицированная матрица отслеживания требований
– Обновленные тест-кейсы
– Найденные и описанные инциденты
На этапе завершения тестирования создается отчет о результатах тестиро-
вания. QA-команда обсуждает и анализирует найденные инциденты, делает вы-
воды из возникших проблем, чтобы избежать подобных проблем в будущем. Про-
водят оценку критериев завершения тестирования, основываясь на критериях по-
крытия тестами, трудозатратах. Подготавливают отчет о завершении тестирова-
ния и отчет для заказчика с количественными и качественными характеристиками
тестируемой системы.
Результат этапа:
– Отчет о завершении тестирования4. Тестирование документации.
4.1. Проектная и продуктная документация
Тестирование документации – это начальная стадия процесса тестирования,
которая выступает как система раннего оповещения об ошибках. Процесс тести-
рования начинается с документации и требований. Тестирование документации
предполагает начало тестирования еще до разработки продукта.
Рассмотрим типы документации при разработке ПО и техники тестирования
документации.
4.1.1. Нормативная документация
Документация проекта состоит из огромного числа документов, начиная от
писем, которые посылают друг другу сотрудники, до технического задания и ин-
струкции по инсталляции и использованию. Для написания документации на про-
граммную систему используются отечественные серии ГОСТов 19.ХХХ и
34.ХХХ, например, ГОСТ 34.201-2020 «Информационные технологии. Комплекс
стандартов на автоматизированные системы. Виды, комплектность и обозначение
документов при создании автоматизированных систем».
Серия ГОСТов 19 (ГОСТ 19.ххх «Единая система программной документа-
ции (ЕСПД)») посвящена разработке и эксплуатации программ и программных
документов.
При проверке качества ПО QA-инженер сверяет фактические результаты ра-
боты программной системы с теми, которые зафиксированы в техническом зада-
нии. Структура документа может быть различной в зависимости от того, на ос-
нове какого ГОСта она была разработана.
Уточним, что в ГОСТах 19 серии идет описание программы и программного
обеспечения. В серии ГОСТов 34 серии показана структура документов для опи-
сания автоматизированной системы, в состав которой помимо программного
обеспечения входят организационное, методическое, правовое, лингвистическое
и другие виды обеспечения. Таким образом, АС, как правило, несёт в себе орга-
низационное решение под конкретного пользователя и заказчика, а Программа
может быть создана и растиражирована под большое количество пользователей
без привязки к какому-либо предприятию.4.1.2. Проектная и продуктная документация
Российские ГОСТЫ разработаны на основе международных стандартов
ISO/IEC и IEEE. Эти документы также включают описание документов, которые
относятся к проекту и программному продукту.
Продуктная документация (product documentation) используется проектной
командой во время разработки и поддержки продукта.
Она включает:
1. План проекта и в том числе тестовый план.
2. Требования к программному продукту и функциональные спецификации.
3. Архитектуру и дизайн.
4. Тест-кейсы и наборы тест-кейсов.
5. Технические спецификации, такие как схемы баз данных, описания алго-
ритмов, интерфейсов и т. д.
Проектная документация (project documentation) включает в себя как про-
дуктную документацию, так и некоторые дополнительные виды документации и
используется не только на стадии разработки, но и на более ранних и поздних
стадиях (например, на стадии внедрения и эксплуатации). Она включает: пользо-
вательскую и сопроводительную документацию, такую как встроенная помощь,
руководство по установке и использованию, лицензионные соглашения и т. д.
Рассмотрим примеры.
Программный продукт по распознаванию рукописных символов и переводу
их в цифровой вид – это продукт. Разработка интерфейса тестового стенда для
проведения нагрузочного тестирования – это тоже продукт. Проведение ком-
плексного тестирования любого веб-приложения – это проект.
Документация (или мануал) создается для того, чтобы найти решение или
выход из любой возникшей проблемной ситуации. Поэтому документация на про-
екте должна обладать следующими свойствами (рис.1).Рисунок 1 – Свойства документации
Любая документация должна содержать описание именно той функциональ-
ности, которая присутствует в приложении. И данное описание должно касаться
абсолютно всей функциональности, а не только наиболее значимой.
У пользователя никогда не должно возникать проблем с поиском необходи-
мой ему информации. Поэтому необходимо структурировать информацию и со-
здать удобную навигацию среде всех документов проекта. Древовидная структура
файлов, закладки и прочее должны быть на видном месте сразу, как пользователь
открывает документ. Алфавитный указатель, поиск по содержанию помогут поль-
зователю найти решение или описание проблемы.
– Текстовая составляющая документов должна быть с четкой и ясной струк-
турой, чтобы пользователь мог в любой момент вспомнить, где остановился или
понять, в каком абзаце содержится именно та информация, которая нам необхо-
дима.
– При выполнении абсолютно одинаковых манипуляций с программой необ-
ходимо пошаговое описание действий во всех случаях. Это может быть как пря-
мое повторение инструкций, так и ссылка на уже существующие.
– В любой документации может использоваться масса терминов, аббревиа-
тур и сокращений. Каждый из них должен иметь свое значение и расшифровку.
– Документация должна быть максимально понятной для любой целевой
аудитории с разным уровнем квалификации.– Если документация создана и для иностранных пользователей, то необхо-
димо привлечение специалистов данного лингвистического сектора, вплоть до
носителей языка.
Расширим эти подходы пользовательскими историями, которые необходимо
проверить тестировщику при тестировании документации (рис.2).
Рисунок 2 – Пользовательские истории
4.1.3. Тестирование на основе техник взаимного просмотра
Тестирование документации относится к нефункциональному тестирова-
нию. Тестирование документации базируется на техниках взаимного просмотра
или рецензирования.
Они могут быть представлены в следующих формах.
1. Беглый просмотр может выражаться как в показе автором своей работы
коллегам с целью создания общего понимания и получения обратной связи, так и
в простом обмене результатами работы между двумя и более авторами с тем,
чтобы коллега высказал свои вопросы и замечания. Это самый быстрый, дешёвый
и часто используемый вид просмотра.
Для запоминания: аналог беглого просмотра – это ситуация, когда вы в школе
с одноклассниками проверяли перед сдачей сочинения друг друга, чтобы найти
описки и ошибки.
2. Технический просмотр (technical review) выполняется группой специали-
стов. В идеальной ситуации - каждый специалист должен представлять свою об-
ласть знаний. Тестируемый продукт не может считаться достаточно качествен-
ным, пока хотя бы у одного просматривающего остаются замечания.
Для запоминания: аналог технического просмотра – это ситуация, когда не-
кий договор визирует юридический отдел, бухгалтерия и т.д.3. Формальная инспекция (inspection) представляет собой структурирован-
ный, систематизированный и документируемый подход к анализу документации.
Для его выполнения привлекается большое количество специалистов. Само вы-
полнение занимает достаточно много времени, потому этот вариант просмотра
используется достаточно редко (как правило, при получении на сопровождение и
доработку проекта, созданием которого ранее занималась другая компания).
Для запоминания: аналог формальной инспекции – это ситуация генеральной
уборки квартиры (включая содержимое всех шкафов, холодильника, кладовки и
т.д.).
4. Следующей техникой тестирования и повышения качества требований яв-
ляется использование техник повторного выявления требований, а также, как от-
дельный вид деятельности – постановка вопросов. Если хоть что-то в требованиях
или в документации вызывает у тестировщика непонимание или подозрение, то
следует задавать уточняющие вопросы аналитикам и потенциальным пользовате-
лям системы.
4.1.4. Программные инструменты для создания документации
Кто может составлять документацию? Каким образом создают документа-
цию, какие инструменты используют, где хранения, кто имеет к ней доступ.
Документацию создают аналитики, разработчики, тестировщики, техниче-
ские писатели и многие другие участники проектной команды.
Текстовые документы можно создавать в текстовых процессорах и редакто-
рах, таких как система набора текста LaTeX, облегчённый язык разметки
Markdown или AsciiDoc (рис.3). Пересылать коллегам через электронную почту.
Проблему версионности и сохранности исходных материалов решать через Git.
Рисунок 3 – Программные инструменты для ведения и тестирования документации
Сборка документов проводить в pdf- или html- форматах. Для решения со-
хранности кода вместе с комментариями и документацией используют подходEverything As a Code (Все Как Код). Эта практика обращения со всеми частями
системы как с кодом. Данный подход позволяет хранить конфигурации, доку-
менты и все остальное вместе с исходным кодом в репозитории, таком как Git.
Тестировщики при таком подходе могут проверять параллельно документацию и
программный код. А также автоматизировать процесс проверки документации с
использованием пользовательских сценариев для проверки неработающих ссы-
лок, неправильных терминов/стилей и ошибок форматирования. Важным преиму-
ществом такого подходя будет автоматизация сборки всех документов проекта в
один релиз.
Наличие качественной документации позволяет повысить репутацию про-
ектной группы: пользователи не стремятся отказаться от продукта, снижается
нагрузка на техподдержку, внутри команды разработки возникает меньше вопро-
сов о том, как должен функционировать продукт.
1.
2.
3.
4.
Список источников
Тестирование программного обеспечения. Базовый курс: практ. пособие. / С.
С. Куликов. — Минск: Четыре четверти, 2015. С. 294.
Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. — СПб: Питер, 2020. С.640.
Статья. Тестирование документации к программным продуктам URL:
https://habr.com/ru/articles/346290/
Справочник QA-инженера. URL https://sergeygavaga.gitbooks.io/4.2. ИСТОЧНИКИ ТРЕБОВАНИЙ
4.2.1 Важность требований
Понятие требования определено в глоссариях международных стандартов и
российских ГОСТов.
Требование – характеристика того, чем система или элемент конфигурации
программного обеспечения должны обладать, чтобы быть приемлемыми для за-
казчика. (Глоссарий ГОСТ Р 51904-2002 «Программное обеспечение встроенных
систем»)
Под требованиями будем понимать описание функциональных возможно-
стей и ограничений, накладываемых на создаваемую программную систему.
(Орлов С.А. «Программная инженерия»: учебник для вузов)
Требование – описание того, какие функции и с соблюдением каких условий
должно выполнять приложение в процессе решения полезной для пользователя
задачи. (Куликов С. С.. Тестирование программного обеспечения. Базовый курс:
практ. пособие. Минск: Четыре четверти, 2015)
В нашем курсе мы придерживаемся следующего определения.
Требование – это описание того, какие функции и с соблюдением каких усло-
вий должно выполнять приложение в процессе решения полезной для пользова-
теля задачи.
В литературе 20-летней давности, о пользователях, их задачах и полезных
для них свойствах приложения в определении требования не было почти ничего
сказано. Пользователь выступал некоей абстрактной фигурой, не имеющей отно-
шения к приложению. В настоящее время такой подход не допустим, т.к. он не
только приводит к коммерческому провалу продукта на рынке, но и многократно
повышает затраты на разработку и тестирование.
Тестировщик в процессе тестирования требований:
1. участвует в проверке и анализе требований,
2. находит неясности и противоречия в требованиях,
3. предоставляет отзыв о функциях и удобстве использования будущего при-
ложения.
Требования являются отправной точкой для определения того, что проектная
команда будет проектировать, реализовывать и тестировать. Аргументом в пользу
тестирования требований является то, что, по разным оценкам, в них зарождается
более 50 процентов всех проблем с программным обеспечением. В итоге есть
риск, что получится результат, показанный на рис.1.Рисунок 1 – Важность требований
На первой фазе проекта клиент пытался объяснить желания менеджеру про-
екта на словах, без составления документации. Менеджер понял, как смог, и пе-
редал информацию аналитику для составления технического задания. Програм-
мист реализовал задуманное и представил результат для передачи клиенту. Биз-
нес-консультант приукрасил результаты. Документирование реализованного про-
граммного продукта также не сделано. Единственным совпадением в результате
и пожелании заказчика было дерево и веревка. Стоимость этого проекта для кли-
ента была очень большой, но результат не совпал с ожидаемым клиентом. По-
этому проект провален. Эта история показывает важность получения первичных
требований.
4.2.2 Первичные и детальные требования
Первичные требования документируют желания и потребности заказчика и
должны быть составлены на языке, понятном заказчику.
Требования формулируют, ЧТО система делает. Например, возможно такое
требование для приложения в финансовой сфере: клиенту предоставлены возмож-
ности добавления, снятия денег со счета, а также просмотр состояния счета.Детальные требования документируют требования в специальной форме.
Например, данные о лицевых счетах будут сохранены в БД под управлением
СУБД POSTGRESS.
Источниками требований выступают пользователи, заказчики и разработ-
чики программной системы. Как правило, на этапе сбора требований работают
аналитики, тестировщики могут им помогать.
Рисунок 2 – Источники требований
4.2.3 Техники выявления требований
Для выявления требований применяют множество техник. Рассмотрим их в
контексте взаимодействия с пользователем (рис.3).
Рисунок 3 – Техники сбора требованийКонтактные методы
Интервью. Самый универсальный путь выявления требований, заключаю-
щийся в общении аналитика и представителя заказчика. Интервью может прохо-
дить в классическом понимании этого слова: беседа в виде «вопрос-ответ», в виде
переписки и т.п. Главным здесь является то, что ключевыми фигурами выступают
двое – интервьюируемый и интервьюер.
Работа с фокусными группами. Может выступать как вариант «расширен-
ного интервью», где источником информации является не одно лицо, а группа
лиц. Они, как правило, представляют целевую аудиторию пользователей, напри-
мер, группа из отдела бухгалтерии или приемной комиссии вуза.
Анкетирование позволяет автоматически собрать и обработать огромное ко-
личество ответов от огромного количества респондентов. Ключевым фактором
успеха является правильное составление анкеты, правильный выбор аудитории и
правильное преподнесение анкеты.
Семинары позволяют группе людей очень быстро обменяться информацией.
Они хорошо сочетаются с техниками интервью, анкетированием, прототипирова-
нием и моделированием.
Мозговой штурм позволяет за минимальное время сгенерировать большое
количество идей, которые в дальнейшем можно не спеша рассмотреть с точки зре-
ния их использования для развития проекта.
Методы отслеживания требований
Следующая группа методов основана на бесконтактной форме.
Наблюдение. Может выражаться в буквальном наблюдении за некими про-
цессами, или во включении аналитика в эти процессы в качестве участника. С од-
ной стороны, наблюдение позволяет увидеть то, о чём могут умолчать интервью-
ируемые, анкетируемые и представители фокусных групп.
Анализ и изучение документов. Позволяет выявить требования в регламенти-
рующих деятельность организации документах.
Самостоятельное описание. Является техникой фиксации и формализации
требований. Важно не пытаться самому «придумать требования за заказчика», а в
спокойной обстановке самостоятельно обработать собранную информацию и ак-
куратно оформить её для дальнейшего обсуждения и уточнения.
Методы, основанные на моделировании.
Такие методы показывают динамику связи между «бизнес-процессом и вза-
имодействием» и «техническим процессом и взаимодействием».Взаимодействие с бизнес-процессами рассмотрим на примере: «договор на
закупку формируется отделом закупок, визируется бухгалтерией и юридическим
отделом…». Взаимодействие на основе технических процессов иллюстрирует
следующий пример: «платёжное поручение генерируется модулем “Бухгалте-
рия”, шифруется модулем “Безопасность” и передаётся на сохранение в модуль
“Хранилище”»).
Прототипирование. Состоит в демонстрации и обсуждении промежуточных
версий продукта. Например, дизайн страниц сайта может быть сначала представ-
лен в виде картинок – датафреймов, и затем свёрстан.
4.2.4 Функциональные и нефункциональные требования
По классификации Карла Вигерса различают функциональные и нефункцио-
нальные требования.
Функциональные требования описывают поведение системы и функции, ко-
торые она должна выполнять.
Нефункциональные требования относят к характеристикам системы и ее
внешнего окружения.
1. Функциональные требования показывают, ЧТО должна выполнять про-
грамма, в них устанавливают границы разработки проекта. Например, требуется
распознать текст. В функциональных требованиях четко прописывают рукопис-
ный текст или машиночитаемый, с шаблонных документов или написанный в
произвольной форме. Для понимания потенциальными пользователями зафикси-
рованных в техническом задании требований используют use case – пользователь-
ские сценарии. При проверке функциональных требований проводят системное,
интеграционное тестирование, используют E2E и API тестирование.
Пример функциональных требований: конвертация форматов файлов, распо-
знавание текстов, редактирование фотографий, вычисление данных по введенным
значениям, регистрация в личном кабинете, онлайн-покупки товаров, возможно-
сти редактирования текстов, обмена сообщениями и т.д.
2. Под нефункциональными требованиями понимают свойства системы, ко-
торыми она должна обладать при реализации своего поведения: надежность, мас-
штабируемость, удобство использования. Они фиксируют, каким образом будет
работать система. Нефункциональные требования могут описать только квалифи-
цированные технические специалисты или разработчики системы. Проверку ка-
чества проводят с помощью нагрузочного и юзабилити тестирования. Обяза-
тельно проводят нагрузочное тестирование и тестирование безопасности.4.3. УРОВНИ И СВОЙСТВА ТРЕБОВАНИЙ
При создании автоматизированных систем (АС) и разработке программного
обеспечения требования играют ключевую роль. Наличие четких и понятных тре-
бований является критически важным для успеха проекта, ведь без них участники
проекта не смогут создать качественное ПО, которое соответствует ожиданиям
пользователей, в рамках отведенных сроков и бюджета. Важно, чтобы проектные
команды понимали, на каком этапе разработки ПО с какими требованиями им
придется работать. Проведем классификацию требований на основании рекомен-
даций Карла Вигерса. Как правило, именно в такой классификации на собеседо-
вании ожидают получить ответ от соискателя вакансии QA-инженера.
Все виды требований отражены в документации ГОСТ 34 серии и в рекомен-
дациях Карла Вигерса, специалиста в области разработки программного обеспе-
чения. В этих документах описаны одни и те же сущности. Мы будем рассматри-
вать требования с позиции, изложенной Карлом Вигерсом. Он выделяет три
уровня (рис.1):
1) бизнес-требования;
2) пользовательские требования;
3) требований к программному продукту.
На рисунке пунктирные линии показывают информационное «влияние» од-
них элементов диаграммы на другие, сплошные линии означают «содержатся».
При переходе с одного уровня на другой формируют документы:
а) Документ о концепции и границах (vision and scope document), агрегирую-
щий бизнес-требования к ПО.
б) Документ о вариантах использования (use-case document), описывающий,
какой функционал разрабатываемой программной системы доступен каждой
группе пользователей.
в) Спецификация требований (software requirements specification, SRS), объ-
единяющая в себе описание всех требований к разрабатываемому ПО. Следует
отметить, что каждое требование дискретно и однозначно идентифицируется по-
рядковым номером.
На каждом уровне присутствуют функциональные и нефункциональные
требования.Рисунок 1 – Уровни и типы требований по К.Вигерсу
Бизнес-требования показывают высокоуровневые цели, ради которой раз-
рабатывается продукт (зачем вообще он нужен, какая от него ожидается польза).
Результатом выявления требований на этом уровне является общее видение –
документ, который, как правило, представлен простым текстом и таблицами.
Здесь нет детализации поведения системы и иных технических характеристик, но
вполне могут быть определены приоритеты решаемых бизнес-задач и риски.
Примеры бизнес-требований:
а) Необходимо в два-три раза повысить количество заявок, обрабатываемых
одним оператором за смену.
б) Предприятие хочет на 25% снизить затраты на доставку продукции кли-
енту.
На этом же уровне учитывают бизнес правила.
Бизнес-правила описывают особенности принятых в предметной области
(и/или непосредственно у заказчика) процессов, ограничений и иных правил. Этиправила могут относиться к бизнес-процессам, правилам работы сотрудников,
промышленным стандартам, вычислительным алгоритмам, нюансам работы ПО.
Примеры бизнес-правил:
а) Никакой документ, просмотренный посетителями сайта хотя бы один раз,
не может быть отредактирован или удалён.
б) Публикация статьи возможна только после утверждения главным редак-
тором.
На рис.2 представлена блок-схема выставления счета, основанная на бизнес-
правилах организации.
Рисунок 2 – Блок-схема выставления счета
Завершают работу на этом уровне созданием документ, в котором фикси-
руют идею, концепцию и границы проекта.
Пользовательские требования описывают задачи, которые пользователь
может выполнять с помощью разрабатываемой системы, реакцию системы на
действия пользователя, сценарии работы пользователя. Поскольку здесь уже по-
является описание поведения системы, требования этого уровня могут быть ис-
пользованы для оценки объёма работ, стоимости проекта, времени разработки и
т.д. Пользовательские требования оформляются в виде вариантов использования,
пользовательских историй, пользовательских сценариев. Они могут быть пред-
ставлены с помощью UML-диаграмм: например, диаграммы прецедентов, как по-
казано на рис.3.Рисунок 3 – Фиксация пользовательских требований UML-диаграммами
На этом уровне разрабатывают спецификацию пользовательских требова-
ний.
Примерами пользовательских требований могут быть следующие:
а) При первом входе пользователя в систему должно отображаться лицензи-
онное соглашение.
б) Администратор должен иметь возможность просматривать список всех
пользователей, работающих в данный момент в системе.
Требования к программному продукту, отраженные в спецификациях или
ТЗ, агрегируют пользовательские требования и требования со стороны разработ-
чиков. На этом уроне разрабатывают спецификацию требований. В ней фикси-
руют функциональные и нефункциональные требования, системные требования
и ограничения. Системные требования отражают требования к программному
обеспечению, вычислительным мощностям и оборудованию, персоналу. Ограни-
чения показывают условия, ограничивающие выбор возможных решений по реа-
лизации отдельных требований или их наборов. Они существенно ограничивают
выбор средств, инструментов и стратегий при разработке внешнего вида, струк-
туры и архитектуры программной системы.
Примеры ограничений: «Разработка должна вестись на платформе конкрет-
ного вендора», «При аутентификации пользователя должны использоваться био-
метрические методы идентификации».
4.3.1. Процесс формулирования требований
Процесс формулирования требований показан на рис.4. Требования много-
кратно могут проходить проверку, так же их могут переформулировать и добав-
лять новые. Процесс формулирования требований – итерационный, что означает
многократное выполнение последовательности выявления и представления тре-
бований.Рисунок 4 – Процесс формулирования требований
Процесс состоит из четырех этапов:
1. Выявление требований, сбор информации.
2. Первичный анализ требований.
3. Документирование требований (создание документа, спецификации).
4. Проверка требований.
После сбора, анализа и документирования требований создают техническое
задание на разработку ПП.
4.3.2. Свойства требований
Основные свойства качественных требований показаны на рис. 5.
Рисунок 5 – Свойства требованийОт качества сформулированных требований зависит качество разработан-
ного на их основе ПО. Поэтому расширим свойства требований. Выделяют рас-
ширенные свойства качественных требований (рис.6).
Рисунок 6 – Расширенные свойства требований
1. единичность означает, что каждое требование атомарно и выполняет
одну задачу или описывает одну ситуацию;
2. корректность подразумевает согласованность между первичными и де-
тальными требованиями;
3. недвусмысленность означает, что требование можно однозначно интер-
претировать, в его описании отсутствуют слова, непонятные разработчикам или
заказчику;
4. непротиворечивость показывает отсутствие противоречий между сфор-
мулированными требованиями и не содержит внутренних противоречий;
5. приоритеты требования – существенное, желательное или необязатель-
ное, определяют важность и необходимость выполнения требования;
6. проверяемость позволяет протестировать требование на правильность ре-
ализации;
7. модифицируемость характеризует простоту внесения изменений в от-
дельные требования и в набор требований;
8. выполнимость показывает возможность реализации требования в рамках
бюджета, силами конкретной команды разработчиков с помощью конкретного
стека программных технологий.4.4. Тестирование требований
Правильно собранные качественные требования позволяют реализовать про-
граммный продукт с требуемым уровнем качества в установленные сроки без
нарушения бюджета. Важно, чтобы каждое требование было зафиксировано в
техническом задании и затем проверено на каждом этапе реализации ПО.
При тестировании требований придерживаются следующих принципов:
– тестирование требований проводиться до старта разработки ПО;
– тестирование требований проводится аналитиками и тестировщиками;
– выявленные во время тестирования требований дефекты должны быть за-
несены в баг-трекинговую систему;
– о выявленных во время тестирования требований дефектах необходимо
предупредить команду;
– глубина тестирования требований зависит от уровня их детализации;
– на каждое требование должно быть сделано хотя бы 2 тест-кейса для про-
верки позитивного и негативного сценария.
Техники тестирования требований похожи на тестирование документации
(рис.1).
Рисунок 1 – Техники тестирования требований
Существуют взаимный просмотр, макетирование и специальные техники, та-
кие как, например, матрица требований. Также используют автоматизированноетестирование. Автоматизированное тестирование – процесс, представляющий со-
бой имитацию интерактивных действий пользователя и проверку результатов
этих действий. Имитация действий пользователя осуществляется при помощи
набора объектов встроенного языка, предоставляющих доступ к логической мо-
дели интерфейса клиентского приложения, и элементов форм.
В своей работе при тестировании требований QA-инженеры используют мат-
рицу трассировки требований (рис.2).
Рисунок 2 – Матрица трассировки требований
Матрица трассировки требований – это документ табличного вида, предна-
значенный для контроля выполнения требований к продукту.
По матрице требований видны требования и проверяющие их тест-кейсы.
Важно, чтобы каждое требование было проверено хотя бы один раз.
Матрицу трассировки требований часто называют матрицей отслеживания
требований, Матрицей прослеживаемости требований, Матрицей сверки требова-
ний.
Матрицу создают в табличной форме в любом табличном редакторе, напри-
мер, Яндекс таблицах.
Кейс. Рассмотрите пример прямой матрицы трассировки требований для
приложения по покупке билетов. В ней для каждого требования созданы тест-
кейсы и показан их статус в случае неудачного завершения (рис.3).Рисунок 3 – Матрица трассировки для приложения по покупке билетов
Применение матрицы трассировки требований гарантирует, что каждое тре-
бование не пропущено при реализации программного продукта и протестировано
по всем потенциальным сценариям взаимодействия.
1.
2.
3.
4.
5.
6.
Список источников
Тестирование программного обеспечения. Базовый курс: практ. пособие. / С.
С. Куликов. – Минск: Четыре четверти, 2015. С. 294.
Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. – СПб: Питер, 2020. С.640.
Вигерс К. Разработка требований к программному обеспечению / Пер. с англ.
– СПб.: BHV, 2020. С.736.
Справочник QA-инженера. URL: https://sergeygavaga.gitbooks.io/
Большой учебник тестировщика. URL: https://testengineer.ru/
Назина О. Что такое тестирование. Курс молодого бойца. СПб: БХВ, 2022.
С.592.5. Классификация тестирования
Проверку качества разрабатываемого программного продукта проводят раз-
ными методами в зависимости от типа поставленной задачи тестирования. Опре-
деление техник тестирования представлены в глоссарии ISTQB и в отечественных
ГОСТах, например серии 56920 «Системная и программная инженерия. Тестиро-
вание программного обеспечения». Рассмотрим упрощенную классификацию те-
стирования.
5.1. Классификация по способу тестирования
1. По запуску кода на исполнение:
– Статическое тестирование — без запуска кода на исполнение.
– Динамическое тестирование — с запуском кода.
2. По степени автоматизации:
– Ручное тестирование — тест-кейсы выполняет человек.
– Автоматизированное тестирование — тест-кейсы частично или полно-
стью выполняет специальное инструментальное средство.
3. По принципам работы с приложением
– Позитивное тестирование — все действия с приложением выполня-
ются строго по инструкции без ввода недопустимых действий, некор-
ректных данных.
– Негативное тестирование — в работе с приложением выполняются не-
правильные операции и используются невалидные данные, потенци-
ально приводящие к ошибкам.
Негативные тесты НЕ предполагают возникновения в приложении ошибки.
Они показывают, что приложение успешно справится с неправильными данными.
Например, отобразит сообщение «Делить на ноль запрещено» или «Введите кор-
ректный email».
Классификацию по запуску кода на исполнение
Подробнее рассмотрим подходы при динамическом (с запуском кода) и ста-
тическом тестировании (без запуска кода).
При статическом тестировании проверяют:
– Документы: требования, тест-кейсы, описания архитектуры приложе-
ния, схемы баз данных.
– Графические прототипы (например, эскизы пользовательского интер-
фейса).– Код приложения (что часто выполняется самими программистами в
рамках аудита кода, являющегося специфической вариацией взаим-
ного просмотра в применении к исходному коду). Код приложения
также можно проверять с использованием техник тестирования на ос-
нове структур кода.
– Параметры (настройки) среды исполнения приложения.
– Подготовленные тестовые данные.
Динамическое тестирование
Это тестирование с запуском кода на исполнение. Запускаться на исполнение
может как код всего приложения целиком, в частности системное тестирование,
так и код нескольких взаимосвязанных частей (интеграционное тестирование), от-
дельных частей (модульное или компонентное тестирование) и даже отдельные
участки кода. Основная идея этого вида тестирования состоит в том, что проверя-
ется реальное поведение (части) приложения.
В небольших проектах хорошо структурированное статическое тестирование
составляет примерно две трети объема QA-операций (рис.1).
Рисунок 1 – Соотношение динамического и статического тестирования
Статическое тестирование предназначено для предотвращения багов. При
динамическом тестировании находят дефекты после реализации приложения.
Также следует отметить, что статическое тестирование не дает представление об
удобстве использования приложения.Классификацию по уровням тестирования
Классификацию по уровням тестирования удобно представлять в виде пира-
миды тестирования (рис.2).
Рисунок 2 – Пирамида тестирования
Выделяют четыре уровня пирамиды тестирования (ISTQB Glossary
(https://glossary.istqb.org/en/search/).
Уровень тестирования – активности тестирования, объединенные в группу
исходя из общих характеристик, связанных с SDLC.
Компонентное/модульное (unit testing) фокусируется на компонентах/моду-
лях/классах, которые могут быть проверены изолированно/отдельно. Юнит или
модульное тестирование, проводит разработчик. Проверяют отдельные неболь-
шие части приложения.
Интеграционное тестирование (integration testing) фокусируется на взаимо-
действии между компонентами / модулями, системами. В тестировании интегра-
ции принимают участие разработчик и тестировщик.
Системное и приемочное тестирование осуществляет QA-инженер. Систем-
ное тестирование (system testing) фокусируется на поведении всей системы в це-
лом с точки зрения конечных пользователей.Приемочное тестирование (acceptance testing) фокусируется на поведении
всей системы в целом. Оно дает возможность оценить готовность системы к раз-
вертыванию и использованию.
Классификация по доступу к коду и архитектуре приложения
Тестирование можно проводить методами Черного, Белого или Серого
ящика (рис.3).
Рисунок 3 – Классификация по доступу к коду
Тестирование «Черного ящика» базируется на знаниях функциональных тре-
бований к системе. Доступ к коду отсутствует.
Тестирование «Белого ящика» основано на полном доступе к программному
коду и на знаниях об устройстве программной системы.
Тестирование «Серым ящиком» подразумевает, что тестировщик обладает
частичным доступом к программному коду и архитектуры. Это комбинация ме-
тодов «Белого ящика» и «Чёрного ящика».
Классификация по степени важности тестируемых функций
Следующая – классификация по степени важности тестируемых функций (по
уровню функционального тестирования).
Дымовое тестирование – проверка самой важной, самой ключевой функци-
ональности, неработоспособность которой делает бессмысленной саму идею ис-
пользования приложения.
Тестирование критического пути – проверка функциональности, исполь-
зуемой типичными пользователями в типичной повседневной деятельности.Расширенное тестирование – проверка всей (остальной) функционально-
сти, заявленной в требованиях.
Классификация, связанная с изменениями программного кода
После проведения необходимых изменений, таких как исправление бага/де-
фекта, программное обеспечение должно быть протестировано снова (перетести-
ровано) для подтверждения того факта, что проблема была действительно решена.
Ниже перечислены виды тестирования, которые необходимо проводить после
установки программного обеспечения, для подтверждения работоспособности
приложения или правильности осуществленного исправления дефекта:
Дымовое тестирование направлено на быструю проверку функционала.
Пример, регистрация в личном кабинете пользователя интернет-магазина прохо-
дит успешно.
Регрессионное тестирование направленно на проверку того, что в ранее ра-
ботоспособной функциональности не появились ошибки, вызванные изменени-
ями в приложении или среде его функционирования. Примеры изменений: устра-
нение дефекта, слияние кода, миграция на другую операционную систему, базу
данных, веб-сервер или сервер приложения.
Фредерик Брукс в книге «Мифический человеко-месяц» писал, что исправ-
ление одной ошибки с большой вероятностью (20–50 %) влечёт появление но-
вой». Регрессионными могут быть как функциональные, так и нефункциональные
тесты. Регрессионное тестирование используют команды, работающие по devops.
Рассмотрим пример тестирования сайта ЛЭТИ. На нем появился новый переход
на страницу Цифровые кафедры. Необходимо проверить, что добавление нового
функционала не повлияет на доступность других страниц.
Тестирование сборки (Build Verification Test) направлено на определение
соответствия выпущенной версии критериям качества для начала тестирования.
По своим целям является аналогом дымового тестирования, направленного на
приемку новой версии.
Санитарное тестирование или проверка согласованности/исправности
(Sanity Testing) – узконаправленное тестирование, достаточное для доказатель-
ства того, что конкретная функция работает согласно заявленным в спецификации
требованиям. В отличии от дымового, санитарное тестирование направлено на
проверку правильности работы конкретной функции (рис.4). Пример. На стра-
нице входа на платформу интернет-магазина имеем дефект: поле пароля прини-
мает не менее 4 цифр, а в требованиях говорится, что это поле должно содержатьне менее 8 цифр. После внесения изменений разработчика QA-команда проверяет,
сработали ли изменения; а также проверяет, не повлияли ли эти изменения на дру-
гие функции. Таким образом, страница входа и страница профиля валидируют са-
нитарным тестированием.
Рисунок 4 – Отличия санитарного от дымового теста
Тестирование классифицируют по объекту тестирования.
Выделяют функциональное и нефункциональное типы тестирования.
Функциональное тестирование – тестирование, основанное на сравнитель-
ном анализе спецификации и функциональности компонента или системы. Отве-
чает на вопрос «Что должно быть сделано?». Типы тестирований: системное, ин-
теграционное, E2E, API. Часто описывают в use-case диаграммах.
Тестирование безопасности – тестирование программного продукта с целью
определить его способность при использовании оговоренным образом оставаться
в рамках приемлемого риска причинения вреда здоровью, бизнесу, программам,
собственности или окружающей среде.
Тестирование защищенности – тестирование с целью оценить защищенность
программного продукта от внешних воздействий, например, от проникновений.
На практике зачастую под термином тестирование безопасности понимают в том
числе и тестирование защищенности.Тестирование требований – это проверка требований на соответствие основ-
ным атрибутам качества.
Рассмотрим нефункциональные виды тестирования, направленные на
проверку характеристик: внешний вид, удобство использования, скорость работы.
Отвечают на вопрос: «Как должно быть сделано?»
Тестирование пользовательского интерфейса – тестирование, выполняе-
мое путем взаимодействия с системой через графический интерфейс пользова-
теля, например, правописание выводимой информации; расположение и вырав-
нивание элементов графического интерфейса; соответствие названий форм / эле-
ментов GUI их назначению; унификация стиля, цвета, шрифта; окна сообщений;
изменение размеров окна, поведение курсора и горячие клавиши.
Тестирование удобства использования – тестирование с целью определе-
ния степени понятности, легкости в изучении и использовании, привлекательно-
сти программного продукта для пользователя при условии использования в задан-
ных условиях эксплуатации. На этом уровне обращают внимание на визуальное
оформление, навигацию, логичность, наличие обратной связи.
Тестирование доступности – тестирование, которое определяет степень
легкости, с которой пользователи с ограниченными способностями могут исполь-
зовать систему или ее компоненты.
Тестирование производительности – процесс тестирования с целью опре-
деления производительности программного продукта. В рамках тестирования
производительности выделяют нагрузочное тестирование, объемное тестирова-
ние, тестирование стабильности и надежности, стрессовое тестирование.
Тестирование установки – процесс тестирования установки программного
продукта. Включает формальный тест программы установки приложения (про-
верка пользовательского интерфейса, навигации, удобства использования, соот-
ветствия общепринятым стандартам оформления); функциональный тест про-
граммы установки; тестирование механизма лицензирования и функций защиты
от пиратства; проверку стабильности приложения после установки.
Рассмотрим классификацию по природе приложения.
– Тестирование веб-приложений сопряжено с деятельностью в области те-
стирования: совместимости, например, кросс-браузерного тестирования; тестиро-
вания производительности, автоматизации тестирования с использованием широ-
кого спектра инструментальных средств.– Тестирование мобильных приложений также требует повышенного внима-
ния к тестированию совместимости, оптимизации производительности, автомати-
зации тестирования с применением эмуляторов мобильных устройств.
– Тестирование настольных приложений и его особенности зависят от пред-
метной области приложения, нюансов архитектуры, ключевых показателей каче-
ства.
Классификация по формализации подходов
Тестирование на основе тест-кейсов – это формализованный подход, в ко-
тором тестирование производится на основе заранее подготовленных тест-кейсов,
наборов тест-кейсов и иной документации. Это самый распространённый способ
тестирования, который также позволяет достичь максимальной полноты исследо-
вания приложения за счёт строгой систематизации процесса, удобства примене-
ния метрик и широкого набора выработанных за десятилетия и проверенных на
практике рекомендаций.
Исследовательское тестирование – частично формализованный подход, в
рамках которого тестировщик выполняет работу с приложением по выбранному
сценарию, который, в свою очередь, дорабатывается в процессе выполнения с це-
лью более полного исследования приложения. Ключевым фактором успеха при
выполнении исследовательского тестирования является именно работа по сцена-
рию, а не выполнение разрозненных бездумных операций.
Свободное (интуитивное) тестирование (ad hoc) – полностью неформали-
зованный подход, в котором не предполагается использования ни тест-кейсов, ни
чек-листов, ни сценариев – тестировщик полностью опирается на свой професси-
онализм и интуицию для спонтанного выполнения с приложением действий, ко-
торые, как он считает, могут обнаружить ошибку. Этот вид тестирования исполь-
зуется редко, когда для исследования некоторого аспекта поведения приложения
отсутствует документация.
Выбор рассмотренных техник тестирования обусловлен систематизацией во-
просов на собеседовании при поступлении на работу QA-инженера. Обратите
внимание, что рассмотрены техники тестирования, уровни тестирования и типы
тестирования.5. Классификация тестирования
5.2 Классификация по уровню тестирования
Для визуализации по уровням тестирования используют пирамиду тестиро-
вания. С ее помощью проводят группировку тестов по уровню детализации и их
назначению (рис.1).
Рисунок 1 – Соотношение уровней тестирования в пирамиде тестирования
Для каждого уровня тестирования тестировщик должен написать тесты,
проверяющие работоспособность компонентов конкретного уровня.
На уровне юнит-тестирования проверяют правильность реализации всех про-
граммных модулей. Интеграционное тестирования проводят с помощью техник
тест-дизайна. Системное тестирование проверяет правильную работу приложе-
ния в целом.
На уровне приемного тестирования уточняют, что все требования пользова-
телей выполнены.
Базис тестирования
Для каждого уровня тестирования должны быть определен документ, в соот-
ветствии с которыми проводят тестирование. Таким документом является базис
тестирования. Его определение присутствует в глоссарии ISTQB.
Базис тестирования – это документ, на основании которого определяются
требования к компоненту или системе. Документация, на которой базируются те-
стовые сценарии (глоссарий ISTQB).Также определение базиса тестирования зафиксированы в ГОСТ P 56920
«Системная и программная инженерия. Тестирование программного обеспече-
ния».
Базис – это свод знаний, используемых в качестве базы проекта тестирования
и контрольных примеров. Там же можем найти определение тестового условия.
Тестовое условие – тестируемый аспект компонента или системы, такой как
функция, транзакция, возможность, атрибут качества или структурный элемент,
идентифицированные как базис тестирования (ГОСТ 56920).
Примечание – Базис тестирования может иметь форму документов, таких как
спецификация требований, спецификация проекта или спецификация модуля, но
может также представлять собой недокументированное понимание требуемого
поведения.
Рассмотрим подробнее уровни тестирования с примерами базиса тестирова-
ния для некоторых из них.
Модульное тестирование
Модульное тестирование – тестирование отдельных компонентов программ-
ного обеспечения.
Выполняется разработчиком. Иногда модульное тестирование доверяется
другому разработчику, а не автору кода, для повышения уровня независимости.
Проводят тестирование функциональных и нефункциональных характери-
стик программы. Для ограничения связи с другими модулями используют эмуля-
торы (заглушки и драйвера).
На собеседовании часто называют модульное тестирование юнит-тестирова-
нием или компонентным (рис.2).
Рисунок 2 – Модуль=юнит
Рассмотрим пример тестирования модуля калькулятора (рис.3). Чтобы про-
верить его работоспособность, был вызван фреймворк unitTest и написана про-
грамма, проверяющая на известных входных данных правильность работы основ-
ного модуля. Обратите внимание, что количество строк тестирующего модуля по-
чти в два раза больше, чем количество строк проверяемой программы. Модульноетестирование проводят методом белого ящика с полным доступом к программ-
ному коду.
Рисунок 3 – Модульное тестирование
Задачи модульного тестирования: изолировать отдельные части программы
и показать, что по отдельности все части работают.
Объекты тестирования: компоненты, программы, модули БД.
Базис тестирования: требования к компонентам, детальный дизайн, про-
граммный код.
При модульном тестировании применяют методики:
– тестирование операторов,
– тестирование ветвей,
– тестирование условий,
– тестирование путей.
Для измерения качества проведенного тестирования используют метрики:
– покрытие операторов,
– покрытие альтернатив,
– покрытие путей.
К преимуществам модульного тестирования относят.
1. Возможность протестировать часть программы, не ожидая готовности
остальных частей.
2. Раннее обнаружение дефектов.
3. Программисты обнаруживают и мгновенно исправляют проблемы. Упро-
щенная отладка.
4. Структурное покрытие кода.5. Стоимость тестирования низкая.
6. Упрощает интеграцию между модулями.
Модульное тестирование может снизить уровень неопределенности в каж-
дом из тестируемых модулей и может использоваться в восходящем тестирова-
нии. Когда тестируются сначала части программы по отдельности, а затем все
вместе, интеграционное тестирование становится намного легче.
Тестирование интеграции компонентов
Тестирование интеграции компонентов – это тестирование, выполняемое для
выявления дефектов в интерфейсах и взаимодействии между интегрированными
компонентами (внутри программной системы).
Интеграционное тестирование предназначено для проверки связи между
компонентами, а также взаимодействия с различными частями системы (операци-
онной системой, оборудованием либо связи между различными системами).
Цель интеграционного тестирования: удостовериться, что взаимодействие
двух или более компонентов дает результат, отвечающий функциональным тре-
бованиям, обнаружить проблемы интерфейса
Объектами тестирования являются: подсистемы, инфраструктура, интер-
фейсы.
Базис интеграционного тестирования: проект программы и системы, архи-
тектура, технологический процесс (workflow), сценарии использования.
При интеграционном тестировании различают нисходящее, восходящее и
комбинированное типы тестирования (рис.4).
Рисунок 4 – Типы интеграционного тестированияВосходящее тестирование. Предполагает, что программа собирают и тести-
руют снизу вверх. Модули (компоненты самого нижнего уровня) тестируются ав-
тономно.
Нисходящее тестирование. Автономно тестируют только главный управля-
ющий модуль программу. По завершении тестирования головного комплекса к
нему последовательно присоединяются модули следующего уровня. Тестирова-
ние идет в глубину (по вертикали) и в ширину (по горизонтальным уровням)
При интеграционном тестировании проверяют правильность связей и интер-
фейсов модулей. Применяют метод «Белого ящика».
Нисходящее и восходящее тестирование на собеседовании могут называть
тестированием сверху вниз и снизу вверх. Также могут задать вопрос про тех-
нику «большой взрыв».
Техника «большого взрыва» состоит в том, разработанные модули соби-
рают в виде законченной системы, проводят интеграционное тестирование. Такой
подход значительно сокращает время и стоимость тестирования. Он оправдан в
случае необходимости быстрой передачи продукта заказчику. Тестируются
только самые важные, критические связи между модулями.
Рассмотрим пример. Предположим, в разработанном приложение включено
три модуля: «Страница входа», «Почтовый ящик» и «Удалить электронную
почту».
В этом случае необходимо проверить связи между модулями входа в систему
и почтовым ящиком. Также необходимо протестировать интерфейсную ссылку
между почтовым ящиком и модулем удаления почты (табл.1).
Таблица 1 – Тест-кейсы проверки функциональности
N
1
2
Цель теста
Проверить интерфейсную
связь между модулем
входа в систему и почто-
вым ящиком
Проверить интерфейсную
ссылку между почтовым
ящиком и модулем удале-
ния почты
Описание теста
Ожидаемый результат
Введите учетные дан- Быть направленным в
ные
и
нажмите почтовый ящик
кнопку «Войти»
Из почтового ящика
выберите адрес элек-
тронной почты и
нажмите кнопку уда-
ления
Выбранное
письмо
должно появиться в
папке «Удаленные /
Корзина»Системное тестирование
Системное тестирование – процесс тестирования системы в целом с целью
проверки того, что она соответствует установленным требованиям (ISTQB).
Системные тесты, иногда их называют end-to-end тестами, направлены на
тестирование всей программы в целом, с учётом окружения, в которой программе
предстоит работать. На этом уровне тестирования применяют метод «Черного
ящика». Этот тип тестирования выполняется тестировщиками. Проводят тестиро-
вание функциональных и нефункциональных характеристик программы.
Системное тестирование является разновидностью тестирования методом
«Черного ящика», а, следовательно, не требует знания внутренней структуры кода
или логики.
Включает тестирование взаимодействия с операционной системой и систем-
ными ресурсами.
При системном тестировании применяют техники тест-дизайна:
– Эквивалентное разбиение;
– Анализ граничных значений;
– Тестирование таблицы решений;
– Тестирование всех пар (pairwise);
– Тестирование состояний и переходов;
– Тестирование по сценариям использования.
Проводят измерения и метрики, показывающие качество проведенного
тестирования:
– Покрытие требований;
– Покрытие классов эквивалентности;
– Покрытие граничных значений.
Приемочное тестирование
Приемочное тестирование – формальное испытание системы, проводимое
с целью определения соответствия реализованных требований, бизнес-процессов,
потребностей пользователя приемочным критериям.
На основании результатов приемочного тестирования пользователь, заказчик
или другое уполномоченное лицо принимает решение о приемке системы в
эксплуатацию.Приемочное пользовательское тестирование выполняется заказчиком или
пользователем системы. Поиск дефектов не является главной целью. Пользова-
тельское приемочное тестирование проверяет готовность системы для использо-
вания.
Эксплуатационное тестирование проверяет, насколько система пригодна
для эксплуатации в конкретном операционном окружении.
Альфа тестирование выполняют в стенах компании, которая разрабатывает
программный продукт.
Бета тестирование выполняется заказчиком/пользователем на его оборудо-
вании.
1.
2.
3.
4.
5.
6.
7.
8.
9.
Список источников
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная
инженерия. Тестирование программного обеспечения. Часть 1. Понятия и
определения
Глоссарий ISTQB URL: https://glossary.istqb.org/
Тестирование программного обеспечения. Базовый курс: практ. пособие. /
С. С. Куликов. — Минск: Четыре четверти, 2015. — 294 с.
Орлов С.А. Программная инженерия: учебник. – СПб.: Питер, 2016. – 640 с.
Блог компании Logrocon. URL: https://logrocon.ru/news/intgration_testing
Интеграционное тестирование (Integration Testing) URL:
http://www.protesting.ru/testing/levels/integration.htmlс
М. Фаулер «Пирамида тестов». URL:
https://martinfowler.com/bliki/TestPyramid.html
Ф. Брукс «Мифический человеко-месяц» – СПб.: Питер, 2021. – 368 с.
Справочник QA-инженера. URL https://sergeygavaga.gitbooks.io/5.3. ПРИМЕР ТЕСТИРОВАНИЯ ФОРМЫ ОБРАТНОЙ СВЯЗИ
Кейс. Требуется протестировать форму Обратной связи веб-приложения, ко-
торое состоит из клиентской (frontend) и серверной (backend) частей (рис.1). Кли-
ентская часть содержит форму Обратной связи, текстовые поля и графическую
информацию. Серверная часть состоит из контроллера формы, написанного,
например, на языке PHP, и сервиса e-mail рассылок, подключенного по API.
Рисунок 1 – Клиентская и серверная части формы Обратной связи
а. Клиентская часть (веб-страница) отображает форму Обратной связи.
б. Форма Обратной связи проверяет и отправляет данные на сервер.
в. Контроллер формы является частью встроенного программного интер-
фейса (API) и отвечает за обработку запросов с формы.
г. Сервис e-mail рассылок отвечает за отправку e-mail на почту пользователя.
1. Юнит-тестирование
Примеры юнит-тестирования для модуля «Клиентская часть. Веб-страница
Обратной связи»:
‒ открывается в браузере по указанному URL;
‒ содержит требуемую информацию;
‒ включает форму обратной святи с требуемыми полями и кнопкой Отпра-
вить.
Юнит-тесты для модуля «Серверная часть. Контроллер»:
‒ принимает данные по указанному URL (API end point);
‒ проверяет полученные данные;
‒ формирует данные для компонента e-mail рассылки (без фактической от-
правки);
‒ возвращает требуемые HTTP-ответы в случае успешной отправки e-mail и
при возникновении ошибок.2. Интеграционное тестирование
Компонентное интеграционное тестирование проводят в точках взаимодей-
ствия 5 и 7 (рис.2). Системное интеграционное тестирование выполняют в точках
3 и 9.
Рисунок 2 – Схема взаимодействия между клиентской и серверной частями
Продолжение кейса. Требуется осуществить проверку того, что Сервис
e-mail рассылок инициирует отправку e-mail, а не SMS-сообщений.
Сценарий компонентного интеграционного тестирования:
а. Контроллер формы обращается к Сервису e-mail рассылок с запросом для
отправки e-mail сообщения (5).
б. Сервис e-mail рассылок отправляет письмо (6) и информирует Контроллер
формы об успешном выполнении запроса (7).
в. Если при отправке (6) произошла ошибка, в ответе (7) вернется информа-
ция об ошибке.
Продолжение кейса.
Сценарий системного интеграционного тестирования:
а. Отправить через форму Обратной связи сообщение.
б. Получить e-mail сообщения с данными, оставленными через форму Об-
ратной связи (10).
в. Сравнить полученный результат с ожидаемым.
3. Системное тестирование
Тестирование на этом уровне можно разделить на тестирование клиентской
и серверной частей [1]. При тестировании клиентской части проверяют крос-сбраузерность, кроссплатформенность, юзабилити и т.д. Проверка серверной ча-
сти включает тестирование безопасности, производительности, нагрузочное и др.
В целом систему проверяют на надежность, сохранность, восстановление.
При системном тестировании проверяют соответствие реализованного функ-
ционала и зафиксированного в требованиях. Для рассмотренного кейса проверя-
ется следующее:
а. Работает ли форма Обратной связи во всех поддерживаемых браузерах?
б. Что произойдет, если кто-то отправит 1000 запросов в секунду с формы
Обратной связи на сервис e-mail рассылки?
в. Насколько читабельным является e-mail, который получит пользователь?
г. Не попадает ли письмо в спам?
д. Сохраняются ли данные пользователя, который отправляет форму? Если
«да», то насколько безопасно место хранения?
е. Существует ли способ получения списка отправленных e-mail?
4. Приемочное тестирование
Во время тестирования создают высокоуровневые тесты, которые выполняет
заказчик. Для рассматриваемого кейса сценарий тестирования можно записать в
следующей форме:
а. Заказчик заполняет форму, нажимает на кнопку Отправить.
б. Через 1 секунду он видит сообщение об успешной отправке формы.
в. В течение минуты на почту приходит письмо, содержащее данные, отправ-
ленные с формы.
1.
Список источников
Аграновский А.В. Тестирование веб-приложений: учебное пособие / А.В.
Аграновский, В. С. Павлов, Е.Л. Турнецкая;. - Санкт-Петербург : Изд-во
ГУАП, 2020. - 155 с.5.4. КЛАССИФИКАЦИЯ ПО МЕТОДУ ТЕСТИРОВАНИЯ
При проверке качества разработанной системы принято выделять три ме-
тода тестирования относительно доступа к коду.
Тестирование «черным ящиком» (Black Box) осуществляют на знаниях
функциональных требований к системе. Доступ к коду отсутствует.
Тестирование «белым ящиком» (White Box) основано на полном доступе к
программному коду и на знаниях об устройстве программной системы.
Тестирование «серым ящиком» (Grey Box) подразумевает, что тестировщик
обладает частичным доступом к программному коду и архитектуре. Это комби-
нация методов «белого ящика» и «черного ящика».
Метод тестирования «черным ящиком»
Задачами метода тестирования «Черным ящиком» является выявление сле-
дующих ошибок:
– неправильно реализованные или недостающие функции;
– ошибки интерфейса;
– ошибки в структурах данных или организации доступа к внешним базам
данных;
– ошибки поведения или недостаточная производительности системы
Таким образом, тестировщик не имеет представления о программном коде и
архитектуре системы. Необходимо сфокусироваться на том, что программа де-
лает, а не на том, как она это делает.
К техникам тестирования методом «черного ящика» относят:
1. Дымовое тестирование,
2. Юзабилити-тестирование,
3. Тестирование критического пути,
4. Системное тестирование,
5. Приемочное тестирование и др.
Преимуществами метода «черного ящика».
1. Тестировщик не обязан обладать знаниями в области программирования.
2. Поведение приложения исследуется в контексте реальной среды выполне-
ния и учитывает её влияние.
3. Поведение приложения исследуется в контексте реальных пользователь-
ских сценариев.4. Тест-кейсы можно создавать уже на стадии появления стабильных требо-
ваний.
5. Процесс создания тест-кейсов позволяет выявить дефекты в требованиях.
6. Допускает создание тест-кейсов, которые можно многократно использо-
вать на разных проектах.
Недостатки метода «черного ящика»:
1. Возможно повторение части тест-кейсов, уже выполненных программи-
стами-разработчиками.
2. Высока вероятность того, что часть возможных вариантов поведения при-
ложения останется непротестированной.
3. Диагностика обнаруженных дефектов более сложная, чем при тестирова-
нии с помощью метода «белого ящика».
4. В связи с широким выбором техник и способов тестирования сложно про-
вести оценку трудозатрат.
5. В случае автоматизации тестирования могут потребоваться сложные про-
граммные инструменты (фреймворки).
Метод тестирования «белым ящиком»
К техникам тестирования методом «черного ящика» относят:
1. Модульное тестирование,
2. Автоматизированное тестирование,
3. Тестирование уровня данных и базы данных,
4. Проверка соблюдения бизнес-правил,
5. Аудит кода (без запуска приложения на исполнение, но с возможностью
его просматривания) и др.
Преимущества метода «белого ящика»:
– Показывает скрытые при кодировании проблемы и упрощает их диагно-
стику.
– Тестирование сфокусировано на проверке реализованной функционально-
сти, что повышает вероятность пропуска нереализованных требований.
– Допускает достаточно простую автоматизацию тест-кейсов и их выполне-
ние на самых ранних стадиях развития проекта.
– Обладает развитой системой метрик, сбор и анализ которых легко автома-
тизируется, например, покрытие кода тестами.
Тестовые мероприятия проводят на специальном тестовом стенде или в
среде разработки.Метод тестирования «серым ящиком»
Тестирование «серым ящиком» – это тестирование с частичным доступом к
исходному коду и данным системы. Например, тестировщик имеет доступ к базе
данных приложения только на уровне «чтения» с отсутствием доступа к про-
граммному коду и возможностям самостоятельно реализовывать программные за-
просы. В этом методе сочетаются преимущества и недостатки двух вышеперечис-
ленных методов.
Рассмотрим, каким образом происходит тестирование с использованием ме-
тодов «черного ящика», «белого ящика» и «серого ящика».
Кейс. На веб-странице интернет-магазина находится гиперссылка для про-
смотра карточки товара. Необходимо протестировать гиперссылку с помощью
трех вышеперечисленных методов (табл.1).
Таблица 1. Тестирование гиперссылки
Тестирование
«черным ящиком»
Тестировщик кликает по
гиперссылке и проверяет
осуществление перехода
на требуемую веб-стра-
ницу или веб-элемент.
Тестирование
«белым ящиком»
Тестировщик открывает
программный код ссылки
и проверяет корректность
HTML-код: правильность
синтаксиса и выбора тега;
затем проверяет правиль-
ность записи URL конеч-
ной точки.
Тестирование
«серым ящиком»
1. Тестировщик кликает
по гиперссылке и фик-
сирует переход.
2. Открывает HTML-
код гиперссылки и про-
веряет синтаксис кода и
корректность
конеч-
ного URL.
Кейс. ИТ-компания тестирует формы регистрации и оплаты для провайдера
интернета и телевидения [36]. При регистрации клиент выбирает и оплачивает та-
рифный план, получая дополнительно одну бесплатную услугу, например, под-
ключение
к
партнерской
программе
Яндекс.Путешествий
(https://travel.yandex.ru/). По техническому заданию пользователь должен иметь
возможность создания личного кабинета, оплаты тарифа и фиксации в тарифе од-
ной дополнительной услуги. ИТ-компания работает по Agile, поэтому при воз-
никновении новых требований модифицирует программный продукт под новые
задачи.
Первая задача по регистрации личного кабинета клиента, проведению
оплаты по конкретному тарифу и автоматическому подключению к партнерскойпрограмме Яндекс.Путешествий прошла успешно. Тестировщики провели тести-
рование рассматриваемого функционала методом «черного ящика». Дефектов в
соответствии с представленной спецификацией не обнаружено (рис.1).
Рисунок 1 – Тестирование первой задачи при разработке функционала
личного кабинета
Кейс. Заказчик расширяет программу лояльностей, поэтому перед ИТ-ком-
панией поставлена следующая задача. При регистрации в личном кабинете новые
клиенты должны выбрать одну дополнительную услугу из трех предлагаемых по
партнерским программам. Однако при регистрации новым пользователям был ав-
томатически открыт доступ только к одной дополнительной услуге, реализован-
ной в первом кейсе.
Тестирование методом «черного ящика» выявило данный дефект. Однако,
понимания причины его возникновения стало возможно после проведения тести-
рования методом «белого ящика» с доступом в базу данных веб-системы. Тести-
ровщики обнаружили, что идентификационный номер каждой из трех услуг начи-
нался со слова «партнер» и цифры «1»:
партнер_11 – партнерская программа Яндекс.Путешествия;
партнер_12 – партнерская программ Яндекс.Островок;
партнер_13 – партнерская программа Яндекс.Практикум.
При этом в базу данных все услуги записывались под идентификатором
партнер_1. Данные о новых партнерских услугах не были внесены в специфика-
цию, поэтому тест-кейсы не были составлены.
После получения доступа к коду БД и возможности просмотра записей за-
дача по выбору одного из трех сервисов была решена (рис.2).Рисунок 2 – Тестирование второй задачи по разработке функционала
личного кабинета
Кейс. Заказчик продолжает вносить дополнения в программу лояльности. В
новой редакции клиент может выбрать в личном кабинете любой тариф из пяти
предлагаемых, а также самостоятельно выбрать любую дополнительную услугу.
Для удобства проверки нового функционала разработчики предусмотрели
возможность просматривать при тестировании в режиме «чтения» таблицы БД, в
которых сохранена информация о состоянии личного кабинета. Тестировщики
выбирали при проверке тарифный план и фиксировали правильность установки
отметок о его выборе.
В этом случае тестирование проведено по методу «серого ящика» с частич-
ным доступом к базе данных (рис.3).
Рисунок 3 – Тестирование третьей задачи при разработке функционала
личного кабинета6. Документирование процесса тестирования
Процесс разработки и тестирования программного обеспечения сопровож-
дают множество документов. Каждый документ имеет определенную структуру
и назначение.
Правила их составления зафиксированы в российских ГОСТах 19 и 34 серий:
1. ГОСТ 19.301-79 (СТ СЭВ 3747-82) Программа и методика испытаний. Тре-
бования к содержанию и оформлению.
2. ГОСТ 34.603-92 Виды испытаний автоматизированных систем.
3. ГОСТ Р 59.792-2021 Информационные технологии. Комплекс стандартов
на автоматизированные системы. Виды испытаний автоматизированных систем.
4. ГОСТ 34.003 Информационная технология. Комплекс стандартов на авто-
матизированные системы. Автоматизированные системы. Термины и определе-
ния.
5. ГОСТ 34.601 Информационная технология. Комплекс стандартов на авто-
матизированные системы. Автоматизированные системы. Стадии создания.
6. ГОСТ Р 59.795 Информационные технологии. Комплекс стандартов на ав-
томатизированные системы. Автоматизированные системы. Требования к содер-
жанию документов.
ГОСТы основаны на рекомендациях и международных стандартах ИСО/ИЕК
и IEEE:
1. IEEE Std 829 – 1998 Standard for Software Test Documentation
2. ISO/IEC 13210:1999 (IEEE Std 2003 – 1997) Requirements and Guidelines for
Test Methods Specifications and Test Methods Implementations for Measuring Con-
formance to Posix Standards
3. IEEE Std 1008 – 1993 Standard for Software Unit Testing
4. IEEE Std 1012 – 1998 Standard for Software Varification and Validation
5. IEEE Std 730 – 2002 Standard for Software Quality Assurance Plans.
Внутри команды проекта среди коллег по разработке и тестированию чаще
всего упоминают артефакты тестирования:
1. Тестовый план (Test Plan)
2. Проект теста (Test Design Specification)
3. Спецификация тестовой процедуры / сценария (Test Procedure Specification
/ Test Script)
4. Спецификация теста (Test Case)
5. Отчёт о проведении теста (Test Log)6. Отчёт по дефекту (Test Incident Report / Bug Report)
7. Сводный отчёт по тестированию (Test Summary Report)
Рассмотрим назначение и структуру некоторых из них.
6.1. Тестовый план и тест-дизайн
6.1.1. План тестирования
План тестирования (Test Plan) – это документ, описывающий весь объем
работ по тестированию, начиная с описания тестируемых объектов, стратегии,
расписания, критериев начала и окончания тестирования, до необходимого в про-
цессе работы оборудования, специальных знаний, а также оценки рисков с вари-
антами их разрешения. Тестовый план – это большой многостраничный документ.
Базовая структура документа содержит:
1. объект тестирования,
2. расписания работ,
3. критерии начала и окончания тестирования,
4. методы тестирования,
5. описание ресурсов и инструмент,
6. планирование и оценка времени,
7. процедуры контроля качества.
При составлении тестового плана руководитель команды тестировщиков:
1. расстанавливает приоритеты задач тестирования;
2. планирует ресурсозатраты на тестирование;
3. рассматривает риски тестирования.
В тестовом плане описаны все артефакты: тесты и тест-сьюты, критерии при-
емки результатов тестирования, описание тестируемых элементов, как проводят
каждый тест (рис.1). Разрабатывают матрицу трассируемости.
В матрице сопоставляют все требования пользователя, с соответствующими
тест-кейсами, убеждаясь, что требования проверяет хотя бы один тест-кейс. Мат-
рица создается до утверждения требований и перед выполнением тест-кейсов.Рисунок 1 – Схема плана тестирования
Тестовый план может быть многостраничным документом. Но для команды,
работающей по Agile, удобнее иметь более наглядный документ. В этом случае
создают панель плана тестирования (рис.2).
Рисунок 2 – Панель тестирования
План тестирования можно зафиксировать в табличном виде в Excel, в идее
ментальной карты или в среде системы управления проектами (рис.3). Каждая ко-
манда выбирает свое представление тестового плана.Рисунок 3 – Пример тестового плана в Kaiten
6.1.2. Тест- дизайн
В плане тестирования прописывают тест-кейсы, но чтобы создать каждый
тест-кейс, необходимо продумать, как их создавать, используя техники и методы
тест-дизайна.
Тест-дизайн (Test Design) – процесс проектирования и создания тестовых
случаев, для проведения в дальнейшем проверки ПО с учетом спецификации про-
екта и требований.
Проектирование теста (test design): Процесс перевода общих причин тести-
рования в конкретные тестовые условия и тестовые сценарии. (по терминологии
ISTQB)
Техники тест-дизайна – это советы, рекомендации, и правила, по которым
стоит разрабатывать тест для проведения тестирования приложения. Это не об-
разцы тестов, а только рекомендации к применению.
К задачам тест-дизайна относят:
1. Определение функциональных и нефункциональных требований к прило-
жению.
2. Создание тестовых случаев, которые позволят оценить работоспособность
приложения.
3. Определение методов и подходов, которые будут использоваться для те-
стирования.
4. Создание окружения, необходимого для проведения тестирования.
5. Запуск тестовых случаев и анализ результатов.6. Оценку результатов тестирования и их использование для улучшения ка-
чества продукта.
Тест кейсы разрабатывают: тест-аналитик и тест-дизайнер.
Тест-аналитик определяет, что тестировать
Тест-дизайнер отвечает на вопрос «как тестировать?».
Задача тест аналитиков и дизайнеров сводится к тому, чтобы, используя раз-
личные стратегии и техники тест-дизайна, создать набор тестовых случаев, обес-
печивающий оптимально тестовое покрытие разрабатываемого приложения.
Также тест-дизайном могут заниматься инженер по тестированию, инженер по
автоматизированному тестированию, аналитик по тестированию, менеджер по те-
стированию, разработчик, продукт-менеджер, бизнес-аналитик, дизайнер интер-
фейсов и специалист по безопасности. Каждый из них будет отвечать за различ-
ные аспекты тестирования.
Придерживаются следующей структуры документа:
1. идентификатор документа;
2. описание объекта тестирования, характеристики или комбинации характе-
ристик, подлежащих тестированию;
3. определение метода тестирования и анализа результатов, описание особен-
ностей проведения тестов;
4. список тестов, реализованных на основе данного проекта;
5. определение критериев успешности тестов.
Техники тест-дизайна (Software Testing Techniques) классифицируют (рис.4):
– по запуску кода на исполнение,
– по доступу к коду и архитектуре,
– по уровню детализации,
– по степени важности функций.Рисунок 4 – Классификация техник тест-дизайна
1.
2.
3.
4.
Список источников
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная
инженерия. Тестирование программного обеспечения. Часть 1. Понятия и
определения
Тестирование программного обеспечения. Базовый курс: практ. пособие. / С.
С. Куликов. — Минск: Четыре четверти, 2015. С. 294.
Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. — СПб: Питер, 2020. С.640.
Справочник QA-инженера. URL https://sergeygavaga.gitbooks.io/6. Документирование процесса тестирования
6.2. Чек-листы, тест-кейсы, отчет по тестированию
6.2.1 Чек-листы
При обдумывании тестов – как их проводить и что требуется тестировать –
опытные специалисты по тестированию используют чек-листы. Чек-лист – набор
идей для проверки правильности работы объекта тестирования. Копланд говорит:
«По сути, тестирование – это процесс сравнения того, что есть, с тем, что должно
быть»1.
Рассмотрим пример чек-листа для тестирования числового поля (рис.1).
Рисунок 1 – Форма ввода значения
Для проверки поля ввода данных следует ввести:
– Корректные значения
– Некорректные значения (за пределами валидных диапазонов или нело-
гичные: 200 лет, 88 секунд...)
– Граничные значения
– Пограничные значения
– Дробное число – формат числа (через запятую и через точку)
– Дробное число – округление
– Ноль, единицу, пустое поле
– Максимально большое число (поиск технологической границы)
– Отрицательное число
– Нечисловые и «не совсем числовые» значения
После обдумывания входных значений разрабатывают тест-кейсы.
Тестирование всегда начинают с основных проверок функциональности, с
позитивных тестов и с учетом наиболее ожидаемых ответов пользователей. По-
этому скорректируем чек-лист и выделим основные проверки для возраста
больше, равно или меньше 18 лет (рис.2).
1
Lee Copeland. «A Practitioner’s Guide to Software Test Design». Artech House, 2003. 288 p.Рисунок 2 – Чек-лист базовых проверок
6.2.2 Тест-кейс
После обдумывания возможных типов проверок следует написать тест-кейс.
Тест-кейс – это документ. Его определение можно найти в ГОСТ 56920 «Систем-
ная и программная инженерия» или в международных стандартах, например, в
глоссарии ISTQB. Название сущности в этих документах разное – контрольный
пример и тестовый сценарий.
Контрольный пример (test case):
Совокупность предварительных условий контрольного примера, входов
(включая действия, где это применимо) и ожидаемых результатов, разработанных
для управления выполнением элемента тестирования для достижения целей те-
стирования, включая корректную реализацию, идентификацию ошибок, проверку
качества и получение другой значимой информации2.
Тестовый сценарий (test case):
Набор предусловий, входных данных, действий (где применимо), ожидае-
мых результатов и постусловий, разработанных на основе тестовых условий 3.
Как правило, на собеседовании при приеме на работу ожидают ответ в сле-
дующем формате:
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная инженерия. Тестирование про-
граммного обеспечения. Часть 1. Понятия и определения
3
Глоссарий ISTQB URL:https://glossary.istqb.org/
2Тестовый сценарий – это набор входных данных, условий выполнения и ожи-
даемых результатов, разработанный с целью проверки того или иного свойства
или поведения программного средства.
Под тест-кейсом также понимают соответствующий документ, представляю-
щий формальную запись тест-кейса.
В структуре тест-кейса учитывают следующие поля (рис.3)
– идентификация документа (голубое),
– описание объекта тестирования, характеристики или комбинации ха-
рактеристик, подлежащих тестированию (серое),
– определение метода тестирования и анализа результатов, описание
особенностей проведения тестов (серое),
– список тестов, реализованных на основе данного проекта (желтое),
– определение критериев успешности тестов (зеленое).
Рисунок 3 – Структура тест-кейса
Рассмотрим пример тест-кейса при тестировании поля загрузки файлов в
приложении по удалению фона.
В тест-кейсе указан пошаговый алгоритм проверки требования и ожидаемый
результат по каждому шагу.Тест-кейс удобно записывать в табличном виде. Обратите внимание, что
один тест-кейс проверяет только одно действие, один параметр, одну функцио-
нальность. В рассматриваемом примере мы проверяем возможность загрузки
файла, в названии которого присутствуют спецсимволы. Этот файл заранее под-
готовлен. Тестировщик проверяет каждый этап взаимодействия с приложением
во время активации процесса загрузки.
Таблица 1 – Структура тест-кейса
ИдентификаторГУАП 05.08.2023
Приоритет
Требование, связанное с
тест-кейсомA
Название тест-кейса
Исходные данные
№
1
2
3
4
5
K41
Конвертер, загрузка файла, имя со
спецсимволами
Создать непустой файл с именем
#@%^&*.jpg
Ожидаемый результат
Шаги
Нажать кнопку "Загрузить одно
Появляется окно загрузки файла
или несколько изображений"
Появляется диалоговое окно для вы-
Нажать кнопку "Выбрать"
бора файла для загрузки
Выбрать из списка приготов-
Имя выбранного файла появляется в
ленный файл
поле "Файл"
Диалоговое окно закрывается, в поле
Нажать кнопку "ОК"
файл появляется полное имя файла
Выбранный файл появляется в списке
Нажать кнопку "Добавить"
файлов для обработки
6.2.3. Тест-сьют
Набор тестов (test set): Один или совокупность нескольких контрольных
примеров с общими ограничениями на их выполнение4.
Test suite (test set, test case suite): Набор тестовых сценариев или тестовых
процедур, которые должны выполняться в конкретном тестовом прогоне5.
(ISTQB)
4
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная инженерия. Тестирование программ-
ного обеспечения. Часть 1. Понятия и определения
5 Глоссарий ISTQB URL:https://glossary.istqb.org/Ожидаемый ответ на собеседовании:
Тест-сьют – это набор тест кейсов, которые объединены тем, что относятся к
одному тестируемому модулю, функциональности, приоритету или одному типу
тестирования.
Каждый тест-сьют состоит из более чем одного тест-кейса, которые выпол-
няются последовательно в процессе тестирования.
Возможный тест-сьют показан на примере функции изменения города в од-
ном из приложений (рис.4).
Рисунок 4 – Входные тестовые данные
Требуется создать множество тест-кейсов, которые все проверяют опреде-
ленную функциональность. Для функциональности «Выбор города пользователя»
проверяют возможности:
1. Изменение города из выпадающего списка.
2. Изменение города при переходе из внешнего источника.
3. Изменение города по неправильной ссылке из внешнего источника.
6.2.4. Отчет по дефекту
Если в ходе проведения тестовых мероприятий находят дефект (или инци-
дент), то его фиксируют в отчете по дефекту.
Отчет об Инциденте (Incident Report): Документация по инциденту – о его
проявлении, природе и состоянии6.
Defect report (Bug report): Документация о возникновении, характере и ста-
тусе дефекта7.
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная инженерия. Тестирование программ-
ного обеспечения. Часть 1. Понятия и определения
6
7
Глоссарий ISTQB URL:https://glossary.istqb.org/Этот документ также имеет определенную структуру.
1. идентификатор (id),
2. заголовок (summary),
3. описание (description),
4. шаги воспроизведения (steps to reproduce),
5. воспроизводимость (reproducible),
6. важность (severity),
7. приоритет (priority).
Рассмотрим пример отчета по дефекту, в котором зафиксирована проблема
авторизации с некорректным e-mail в качестве логина. Отчет по дефекту можно
записывать в табличном виде. Важно записать заголовок в формате ЧТО-ГДЕ.
Затем по шагам написать, как был найден инцидент. Показать фактический
результат и написать ожидаемый – из тест-кейса.
Таблица 2 – Пример отчета о нахождении дефекта
ID дефекта:195
Заголовок:Вход на сайт при авторизации с некорректным е-
мейлом в качестве логина.
Предусловия:Нет.
Шаги для воспроизве-
дения:1. Открыть страницу сайта.
2. Нажать на сайте вверху справа кнопку «Войти»,
дождаться появления формы.
3. Ввести в поле «Адрес эл.почты» «Test» (без @),
ввести в поле «Пароль» «1111».
4. Нажать ниже в форме кнопку «Регистрация».
На экране – страница меню для выбора выгружае-
мых данных.
Фактический резуль-
тат:
Ожидаемый результат:На экране – сообщение «Ошибка авторизации. Вве-
дите корректный Адрес эл.почты».
Приложения:Скриншот входа на страницу меню для выбора вы-
гружаемых данных без авторизации.
Тестировщик только фиксирует проблему: никаких выводов о том, почему
она произошла, не делает.6.2.5. Отчет по тестированию
Результат проведения тестовых мероприятий фиксируют в отчетах по тести-
рованию.
Отчет о Завершении Тестирования (Test Completion Report):
Отчет, в котором представлена сводка выполненного тестирования8.
Test report (Test report):
Документация, обобщающая деятельность и результаты тестирования9.
Отчет – это многостраничный документ, содержащий информацию о выпол-
ненных действиях, результатах проведённой работы.
Включает в себя артефакты: таблицы, графики, списки, описания в виде тек-
ста (табл.3).
Таблица 3 – Фрагмент отчета по тестированию
№
Headline
Severity
Description
Result
Expected
result
Attachment
Type
Module
8
1 инцидент
2 инцидент
Нажатие кнопки EN не
При нажатии кнопки EN/RU про-
приводит к изменению
исходит переход на основную
языка
страницу
Major
Major
На главной странице
При нажатии EN/RU, находясь на
сайта при нажатии
любой странице сайта, происхо-
кнопки EN интерфейс не
дит принудительное перенаправ-
перестраивается
ление на главную страницу
на английский язык.
Интерфейс всего сайта
При переключении кнопки с EN
не содержит алгоритмов
на RU и с RU на EN происходит
для детального отобра-
принудительный переход
жения данных на англий-
на основную страницу
ском языке
Нажатие кнопки EN при- При нажатии кнопки EN/RU
водит к изменению языка пользователь остается на текущей
всего функционала сайта странице сайта
Скриншот дефекта
Функциональный
Функциональный
Модуль главной стра-
Модуль многоязычного интер-
ницы
фейса
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная инженерия. Тестирование про-
граммного обеспечения. Часть 1. Понятия и определения
9
Глоссарий ISTQB URL:https://glossary.istqb.org/Структура отчета по тестированию:
1. общие цели и задачи, организации процесса тестирования (управление, ре-
сурсы, метрики, инструментарий, ограничения и т.д.);
2. структура и состав документации;
3. общие результаты и оценки.
Отчеты можно создавать в любых программных средах, например, в таблич-
ном виде. Мы видим пример такого отчета о двух инцидентах. При тестировании
могут быть найдены множество инцидентов в разных модулях приложения раз-
ной степени важности и серьезности.
Важным показателем работы группы тестировщиков являются трудозатраты.
Для их визуализации используют, например, таймланы (рис.5). Пример автомати-
ческого построения диаграмм для отчета по тестированию показан для облачной
системы управления проектами Кайтен (рис.6).
Рисунок 5 – Таймлайны в системе Kaiten
Рисунок 6 – Круговые диаграммы о ходе выполнения работ в системе Kaiten6.3. ПРОЕКТИРОВАНИЕ ТЕСТ-КЕЙСОВ ДЛЯ ТЕСТИРОВАНИЯ
ПОЛЬЗОВАТЕЛЬСКОГО ИНТЕРФЕЙСА
Тестирование пользовательского интерфейса предназначено для проверки
корректности его работы и удобства использования. Ручное тестирование пред-
полагает, что тестировщики взаимодействуют с элементами пользовательского
интерфейса программного обеспечения аналогично конечному пользователю.
Элементы графического интерфейса веб-приложения
Создание графического интерфейса пользователя в формате WIMP
(Windows, Icons, Menus, Pointer) требует, чтобы пользователем через соответству-
ющие формы могла быть получена и передана разнородная информация в фор-
мате короткого или длинного текста, даты или числа, логического представления.
Особенно важным графический интерфейс является для веб-приложений. По
данным маркетингового агентства Nielsen Norman group пользователь в течение
10 секунд принимает решение, остаться в веб-приложении или покинуть его.
Поэтому важно реализовать удобный для пользователя и эффектный с пози-
ции дизайнера интерфейс, все компоненты которого соединены в единую систему
и связаны единым стилем, композицией и назначением (рис.1).
Рисунок 1 – Единый стиль оформления страниц веб-приложения
При тестировании необходимо провести функциональное и нефункциональ-
ное тестирование каждого элемента графического интерфейса пользователя.
Тестирование элементов графического интерфейса
Функциональное тестирование клиентской части веб-приложения проверяет
реакцию информационных элементов на действия пользователей. При проведе-
нии такого тестирования применяют:
‒ технологии позитивного и негативного тестирования;‒ методы граничных условий, разбиения на классы эквивалентности и др.
(будут подробно рассмотрены в следующих разделах).
Графический интерфейс (Graphical User Interface, GUI) позволяет взаимодей-
ствовать с веб-системой с помощью визуальных элементов – полей ввода, кнопок,
иконок, списков и других объектов.
Ниже представлен возможный список проверок:
1. Проверить названия форм и элементов графического интерфейса с точки
зрения их доступности для пользователя и смысловой нагрузки.
2. Проверить в рамках всего приложения единообразие цвета, шрифта, раз-
меров (высоты/ширины), выравнивания полей, категорий меню, вида ссылок,
кнопок и др. (рис.2).
3. Протестировать функциональность и изменение вида ссылок, кнопок, по-
зиций меню при наведении курсора.
4. Уточнить, как выглядят сообщения об успешном или неуспешном завер-
шении действия, о подтверждении действия. Например, если присутствует кнопка
«Отмена», то в правом верхнем углу формы с сообщением имеется символ «Кре-
стик» для альтернативной возможности закрыть форму. Сообщения о подтвер-
ждении удаления по умолчанию активированы на кнопку «Нет».
5. Протестировать изменение размеров окна, изменение масштаба страницы.
Появление скроллинга при уменьшении размера окна. Сохранение взаимного рас-
положения элементов при уменьшении окна или изменении масштаба.
Рисунок 2 – Унификация расположения и вида ссылокК информационным объектам графического интерфейса относят: поля
ввода (input field), кнопки (button), переключатели (radio button), флажки
(checkbox), меню (menu), таблицы (table), гиперссылки (link), сообщения
(message), модальные или всплывающие окна (popups), поле поиска (search field),
комментарии (comment), формы (form), переключатели (toggle). Пример ком-
плексной формы графического интерфейса представлен на рис.3.
Рисунок 3 – Комбинированная форма ввода данных
Проектирование тест-кейсов для тестирования веб-приложения
Тест-кейс должен проверять функциональность системы, зафиксированную
в техническом задании. Он имеет идентификационный номер, в котором зашиф-
рована информация: принадлежность к тест-плану, проверяемое требование, вер-
сия и т.д. Для получения первичного опыта составления тест-кейсов необходимо
основываться на личном опыте взаимодействия с веб-приложением. Для упроще-
ния учебной задачи в рассмотренных ниже примерах присутствуют только базо-
вые структурные элементы тест-кейсов. Альтернативные сценарии взаимодей-
ствия в них не рассмотрены.Кейс. Объектом тестирования является веб-приложение туристической ком-
пании «Русский город» (URL: http://ruscity.ru/, дата обращения 25.05.2024г). Ту-
риста интересует доступность главной страницы веб-приложения, возможность
просмотра туров по диапазону дат, бронирования номера, подписка на новости
туристической компании. Для тестирования такой функциональности составлены
тест-кейсы (табл.1). Обратим внимание, что примеры тест-кейсов носят обобщен-
ный характер и могут изменяться при изменении функциональности веб-прило-
жения.
Таблица 1 – Тест-кейсы для тестирования пользовательского
интерфейса веб-системы http://ruscity.ru/
№
п.п.
1.
2.
3.
4.
5.
Название
сценария
Последовательность
действийОжидаемый результат
Открытие сайта 1. Набрать в адресной
через браузер
строке Google Chrome
Google Chrome адрес http://ruscity.ru/
2. Перейти на веб-
страницу
Закрытие
1. Закрыть веб-прило-
приложения
жения нажатием на си-
при нажатии на стемную кнопку «За-
системную
крыть»
кнопку
«Закрыть»
Расположение
1. Перейти по URL
текста внутри
http://ruscity.ru/
текстового поля 2. Открыть вкладку
Программы
Переход по
1. Открыть вкладку О
вкладкам
компании на
верхнего меню. http://ruscity.ru/
2. Нажать на логотип
компании.Открытие главной стра-
ницы веб-системы
турфирмы «Русский го-
род»
Кликабель-
ность кнопки
Online
бронирования
номеров
1. Перейти на вкладку
Сборные туры
2. Сделать одинарный
щелчок на кнопке
Online бронирования
Веб-приложение закроется
Текстовая информация
находится внутри тексто-
вого поля
1.Осуществляется переход
на страницу О компании.
Название страницы
соответствует.
2. Возврат на
главную страницу
1. Переход на страницу
Сборные туры осуществ-
лен
2. Переход на страницу
online бронирования номе-
ров№
п.п.Название
сценарияПоследовательность
действийОжидаемый результат
6.Кликабель-
ность кнопки
Поиск по дате1. Перейти на вкладку
Сборные туры
2. Кликнуть по кнопке
Поиск по дате1. Переход на страницу
Сборные туры осуществ-
лен
2. Открытие веб-форм для
ввода дат начала и конца
запрашиваемого диапазона
7.Запрос по диа-
пазону дат1. Перейти на вкладку
Сборные туры.
2. Кликнуть по кнопке
Поиск по дате
3. Ввести диапазон дат
для запроса экскурсий с
25.02.2025 по
31.03.20258.Работоспособ-
ность ссылки
Петербург
классический 2
дня1. Перейти на страницу
Группы взрослых
2. Нажать на ссылку
Петербург классиче-
ский 2 дня1. Переход на страницу
Сборные туры осуществ-
лен
2. Открытие веб-форм для
ввода дат начала и конца
запрашиваемого диапазона
3. Вывод список экскур-
сий, проводимых в указан-
ный диапазон
1. Переход на страницу
Группы взрослых
2. Открытие страницы с
информацией об экскурсии
Петербург классический 2
дня
9.Подписка на
новости сайта
через форму
Подписка на
рассылку1. Найти в футере сайта
Подписку на рассылку
2. Заполнить ее дан-
ными:
Ваше имя: Антонина;
Ваш e-mail:
guap@mail.ru
3. Ввести капчу.
4. Нажать на кнопку
Подписаться
1. Подписка на
рассылку найдена.
2. Веб-формы заполнены.
3. Капча введена.
4. Кнопка нажата и под-
писка
оформлена (на указанный
e-mail направлено уведом-
ление).Кейс. Объектом тестирования является центр недвижимости и ипотеки
(URL: https://www.etagi.com/, дата обращения 25.05.2024). Для тестирования со-
ставлены тест-кейсы (табл.2).
Таблица 2 – Тест-кейсы для тестирования интерфейса https://www.etagi.com/
№
п.п.МодульПоследовательность
действийОжидаемый
результат
1.Главная страница2.АвторизацияГлавная страница
отображена в
браузере
Успешная
авторизация
4.Расчет ипотеки5.Выбор другого
городаОткрыть главную страницу
по ссылке:
https://www.etagi.com/
Вход в приложение с
корректными данными
1. Нажать на главной стра-
нице кнопку Войти
2. Ввести корректное значе-
ние в поле «Контактный те-
лефон».
3. Нажать кнопку «Получить
код».
4. Ввести корректное значе-
ние кода из SMS.
5. Указать имя пользователя.
1. Перейти на страницу:
https://www.etagi.com/
2. Найти раздел «Расчет
ипотеки».
3. Заполнить поля: тип недви-
жимости - новостройки, со-
циальная программа - базо-
вая, стоимость недвижимо-
сти – 5000000р, первоначаль-
ный взнос 150000 и срок
кредита 30 лет.
1. Перейти на страницу:
https://www.etagi.com/
2. В шапке веб-приложения
нажать на текущий город, в
данном случае «С-Петер-
бург».
3. В появившемся окне выбрать
город «Москва».
Успешный расчет
ипотеки
Город
С-Петербург
успешно изменен
на Москву№
п.п.
6.
7.
8.
1.
Модуль
Последовательность
действий
Проверить работо-1. Перейти на страницу
способность
https://www.etagi.com/
кнопки «Но-
2. В шапке веб-страницы вы-
востройки в цен-
брать пункт «Новостройки».
тре»
3. Из всплывающего списка вы-
брать пункт «Новостройки в
центре»
Проверить работо-1. Открыть веб-приложение
способность
https://www.etagi.com/.
кнопки возвраще- 2. Зайти на вкладку «Дома и
ния на главную
участки», из всплывающего
страницу
списка выбрать дачи.
3. После перехода на новую
страницу, в шапке веб-при-
ложения найти надпись
«Этажи».
4. Нажать на кнопку «Этажи».
Проверить возмож-
1. Открыть веб-приложение
ность перевода на https://www.etagi.com/.
другой язык
2. В шапке приложения нажать
на текущий язык, в данном
случае русский «RU».
3. Выбрать язык «ENG» из
всплывающего списка.
4. Нажать кнопку «Сохранить».
Ожидаемый
результат
Осуществлен пе-
реход на страницу
с новостройками в
центре
Осуществлен воз-
врат на главную
страницу
Приложение
отображается на
английском языке
Список источников
Аграновский А.В. Тестирование веб-приложений: учебное пособие / А.В.
Аграновский, В. С. Павлов, Е.Л. Турнецкая;. - Санкт-Петербург : Изд-во
ГУАП, 2020. - 155 с.7. Техники тест-дизайна. Проектирование тестов
Для проверки качества разрабатываемого программного продукта исполь-
зуют разные техники тест-дизайна.
Тест-дизайн – это процесс создания тест-кейсов.
Техники тест-дизайн – это правила и подходы, которые помогают создавать
грамотные тест-кейсы.
Техники тест-дизайна помогают:
1. Исключить непродуктивные тест-кейсы и сократить общее количество
кейсов.
2. Покрыть тестами как можно больше функциональности.
3. Провести все тесты и не пропустить ничего важного.
Тестировщики применяют разные техники тест-дизайна в зависимости от
типа решаемой задачи.
– Классы эквивалентности
– Граничные значения
– Попарное тестирование
– Таблица принятия решений
– Диаграмма состояний и переходов
– Тестирование вариантов использования
– Доменное тестирование
Эти техники тестирования относят к методу тестирования черным ящиком.
Рассмотрим подробнее тестирование на основе классов эквивалентности и гра-
ничных значений.
7.1. Тестирование на основе классов эквивалентности
и граничных значений.
7.1.1. Классы эквивалентности
Рассмотрим кейс. В финансовой сфере часто выдают кредит. Предположим,
что его могут получить все клиенты в возрасте от 18 до 60 лет. Построим число-
вую линию (рис.1).
Рисунок 1 – Числовая линияДля покрытия тестами всех входных данных необходимо протестировать все
валидные данные 18,19, 20 лет и так до 60.
И все невалидные данные о младенчества до 17 лет включительно и все года
от 61 и старше.
Результат ввода любого значения из области валидных (допустимых, пра-
вильных) данных будет одинаковым – кредит будет выдан.
Из области невалидных данных тоже одинаковый – кредит не будет выдан.
Существуют области входных данных, на которые системы будет реагиро-
вать одинаково. Это означает, что можно взять только один элемент из каждой
области (её также называют классом эквивалентности).
Эквивалентная область – часть области входных или выходных данных,
для которой поведение компонента или системы считается одинаковым.
В нашем случае выделим следующие диапазоны:
Класс эквивалентности: <18
Класс эквивалентности: 18 – 60
Класс эквивалентности: >60
Алгоритм использования техники классов эквивалентности:
1. Определить классы эквивалентности.
2. Выбрать одного представителя от каждого класса эквивалентности.
3. Выполнить тесты.
При реализации теста достаточно взять только одно значение из каждого
класса эквивалентности (табл.1).
Таблица 1 – Тестовые значения для рассматриваемого примера
Класс эквивалентностиЗначения
<1815
18 – 6045
>6067
7.1.2 Техника граничных значений
Из практики тестирования известно, что наибольшее количество ошибок
происходит на границах классов эквивалентности. Для их фиксации применяют
технику граничных значений.
Проверяют поведение системы на входных значениях около границ, следуя
следующему алгоритму.Граничные значения – это те значения, в которых один класс эквивалентно-
сти переходит в другой.
В рассматриваемом примере: 18 и 60
Алгоритм применения техники граничных значений следующий:
1. Выделить граничные значения.
2. Выбрать ТРИ значения:
ДО границы
ГРАНИЦУ
ПОСЛЕ границы
3. Выполнить тесты.
Таким образом, в рассматриваемом примере около первой границы необхо-
димо взять входные значения 17, 18, 19. Рядом со второй границей – 59, 60, 61
(рис.2).
Рисунок 2 – Применение техники граничных значений
Тестировщики могут комбинировать техники граничных значений и классов
эквивалентности. В этом случае тестирование будет проведено на наборе данных,
которые включают одно значение из валидного класса и входные значения для
тестирования границ классов эквивалентности (рис.3).
Рисунок 3 – Применение комбинированной техники
Список источников
1. Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. — СПб: Питер, 2020. С.640.7.2. ТАБЛИЦА ПРИНЯТИЯ РЕШЕНИЙ
При тестировании системы со сложной бизнес-логикой специалисту по те-
стированию трудно написать тест-кейсы со всеми возможными комбинациями
ввода-вывода. В этой ситуации QA-инженеры разрабатывают тест-кейсы и парал-
лельно продумывают возможные комбинации входных значений. При этом
можно упустить некоторые сценарии, поскольку внимание рассредоточено между
двумя задачами – описаниями тест-кейсов и продумыванием сценариев. Поэтому
применяют таблицу решений, где решения описаны в наглядной легко читаемой
форме [1].
Кейс. Рассмотрим сценарий входа в личный кабинет (рис.1).
Рисунок 1 – Пример тестового задания
Результат проверки пароля и логина может иметь два возможных варианта:
ИСТИНА (TRUE) или ЛОЖЬ (FALSE) (табл.1).
Таблица 1 – Результат проверки пароля и логина
Параметры входаВариант 1Вариант 2
ЛогинTRUEFALSE
ПарольTRUEFALSE
Разработаем сценарии тестирования и проверим все комбинации (табл.2)
ввода значений пароля и логина [2-3].Таблица 2 – Сценарии ввода значений пароля и логина
Номер сценарияРезультат проверки пароляРезультат проверки логина
1TRUEFALSE
2FALSETRUE
3FALSEFALSE
4TRUETRUE
При проектировании таблицы принятия решений используются условия,
правила и действия. Структура в общем виде показана в табл.3. Каждая строка
соответствует условию, влияющему на результат. Таких условий может быть не-
сколько. Сам результат (в англоязычном варианте Action) – действие, которое
проверяется. Каждый столбец – это правило в виде конкретной комбинации вы-
полнения входных условий (правилам соответствуют сценарии из табл.2).
Таблица 3 – Структура таблицы принятия решений
ПРАВИЛО 1
ПРАВИЛО 2
…
ПРАВИЛО N
УСЛОВИЯ
УСЛОВИЕ 1
…
УСЛОВИЕ M
ДЕЙСТВИЯ
ДЕЙСТВИЕ 1
…
ДЕЙСТВИЕ K
Например, для табл.2 может быть записана следующая таблица принятия ре-
шений (табл.4).Таблица 4 – Пример заполнения таблицы принятия решений
ПРАВИЛО 1ПРАВИЛО 2ПРАВИЛО 3ПРАВИЛО 4
Результат про-
верки пароляTRUEFALSEFALSETRUE
Результат про-
верки логинаFALSETRUEFALSETRUE
НетНетНетДа
УСЛОВИЯ
ДЕЙСТВИЯ
Вход разрешен
Таблица принятия решений – это:
1. Техника тестирования для проверки всех возможных комбинаций значе-
ний всех параметров;
2. Способ компактного представления модели со сложной логикой; инстру-
мент для упорядочения сложных бизнес-требований, которые должны быть реа-
лизованы в продукте;
3. Взаимосвязь между множеством условий и действий.
Правила составления таблицы простые. На основе правил комбинаторики
рассчитывают количество столбцов. В рассматриваемом примере всего два усло-
вия, которые принимают по два значения TRUE и FALSE. Поэтому количество
столбцов N= 22=4.
Затем в каждый столбец выписывают все комбинации, начиная с комбинации
правильных данных. Внизу каждого столбца фиксируют действия. Отметим, что
проверяемые действия не обязательно должны быть элементарными, типа
«да/нет». Например, каждому правилу может соответствовать свое числовое зна-
чение (процент по кредиту, размер скидки при покупке и т.п.).
На основании составленной таблицы разрабатывают тест-кейсы, причем
тест-кейсом становится проверка действия для каждого правила. При необходи-
мости полученную таблицу с тестовыми сценариями транспонируют (табл.5).Таблица 5 – Транспонированная таблица
УСЛОВИЕ 1
УСЛОВИЕ 3
…
УСЛОВИЕ М
Тест-кейс 1
Тест-кейс 2
Тест-кейс N
Кейс. Рассмотрим пример составления таблицы принятия решений при те-
стировании нового пароля (табл.7.7). Пусть в требованиях указаны три условия
[4-5].
1) Пароль состоит как минимум из 12 символов.
2) Пароль содержит одновременно буквы и цифры.
3) Пароль не может быть повторно использован, т.е. пользователь не имеет
права установить пароль, который ранее использовался им в системе авторизации.
Для упрощения кейса будем требовать, чтобы новый пароль не совпадал с преды-
дущим (т.е. последним из ранее использовавшихся).
В данном случае существует единственное действие – подтверждение пароля
при соблюдении всех перечисленных условий.
Рассмотрим процесс реализации таблицы.
1. Проанализируем требования и создадим первый столбец таблицы.
Столбец должен состоять из условий выполнения требований и связанных с
ними действий. В нашем примере в требованиях указаны три условия и одно дей-
ствие. Количество столбцов равно количеству правил. Заполним ячейки новых
столбцов значениями TRUE и FALSE. Эти значения обозначают выполнение или
невыполнение того или иного условия требований. В кейсе заданы 3 условия.
Каждое условие принимает 2 значения. Количество правил N= 23=8.
Таблица 6 – Таблица принятия решения для кейса
Условия
Длина не менее 12 символов
Содержит буквы и цифры
Не используют повторно
Действия
Пароль подтвержден
12
3
4
5
6
7
8
T
T
TF
T
F
T
F
F
F
F
F
T
T
F
F
T
F
T
F
F
F
F
F
ДаНет Нет Нет Нет Нет Нет Нет2. Упростим таблицу с учетом целесообразности проверки третьего условия
при невыполнении первого или второго. Очевидно, что можно удалить проверку
некоторых правил для третьего условия, оставив ее только для случая одновре-
менного выполнения первых двух условий.
Например: если пароль состоит из менее 12 символов или содержит только
буквы (и не содержит цифры), то проверка нового пароля на повторное использо-
вание теряет смысл (табл.7).
Таблица 7 – Упрощение таблицы для кейса
Условия
Длина не менее 12 символов
Содержит буквы и цифры
Не используют повторно
Действия
Пароль подтвержден
12
3
4
5
6
7
8
T
T
TF
T
-
T
F
-
F
F
-
T
T
F
F
T
-
T
F
-
F
F
-
ДаНет Нет Нет Нет Нет Нет Нет
3. Удалим повторяющиеся столбцы и получим новую таблицу (табл.8). В рас-
сматриваемом примере исключены повторяющиеся столбцы: 2, 3, 4 = 6, 7, 8
Таблица 8 – Преобразование таблицы для кейса
Условия
Длина не менее 12 символов
Содержит буквы и цифры
Не используют повторно
Действия
Пароль действителен
12
3
4
5
T
T
TF
T
-
T
F
-
F
F
-
T
T
F
ДаНет Нет Нет Нет
В итоге вместо восьми получаем пять тестов, которые покрывают все случаи.
1. Все условия соблюдены: пароль состоит из 12 или более символов, вклю-
чает буквы и цифры и не совпадает с предыдущим. Ожидаемый результат – па-
роль действителен.
2. Пароль состоит менее чем из 12 символов, включает буквы и цифры. Ожи-
даемый результат – пароль не действителен. Поэтому проверять пароль на по-
вторное использование не требуется.3. Пароль состоит из 12 или более символов, но не включает в себя комбина-
цию букв и цифр. Ожидаемый результат – пароль не действителен. При этом про-
верять пароль на повторное использование не требуется.
4. Пароль состоит менее чем из 12 символов и не включает в себя комбина-
цию букв и цифр. Ожидаемый результат – пароль не действителен. Проверять па-
роль на повторное использование не требуется.
5. Пароль состоит из 12 или более символов, включает в себя буквы и цифры,
но совпадает с предыдущим. Ожидаемый результат – пароль не действителен.
1.
2.
3.
4.
5.
Список источников
ГОСТ Р № ИСО/МЭК 27001-2021 от 01.01.2022 "Информационная техноло-
гия. Методы и средства обеспечения безопасности. Системы менеджмента
информационной безопасности».
О. Киселева. Что такое тестирование. Курс молодого бойца. - СПб:БХВ,
2022. – 592 с.
О. Киселева. Decision Table – что это и как применять. URL: https://software-
testing.ru/library/testing/testing-for-beginners/3568-decision-table
ГОСТ Р 52633.0-2006 «Защита информации. Техника защиты информации.
Требования к средствам высоконадежной биометрической аутентифика-
ции». URL:
https://docs.cntd.ru/document/1200048922 (дата обращения
30.06.2024г).
Требования к паролю. База знаний My Kaspersky URL: https://sup-
port.kaspersky.com/KPC/1.0/ru-RU/183862.htm (дата обращения 30.06.2024г).7.3. ПОПАРНОЕ ТЕСТИРОВАНИЕ
Технику попарного тестирования применяют при тестировании методом
«черного ящика» и относят к техникам переборного тестирования. Использование
этой техники позволяет сократить количество комбинаций входных параметров,
уменьшить количество тест-кейсов и сократить время выполнения тестирования.
Кейс. Перед специалистом по тестированию поставлена задача – проверить
веб-приложение на работоспособность в двух браузерах Opera и Яндекс с возмож-
ностью переключения между двумя языками – русским и английским. На устрой-
стве пользователя могут быть установлены операционные системы Windows и
Linux.
Таким образом, имеется три параметра, каждый из которых может принимать
два значения. Поэтому при проектировании тестирования потребуется 2 3 = 8 сце-
нариев (табл.1).
Таблица 1 – Сценарии тестирования для кейса
№
1
2
3
4
5
6
7
8
Браузер
Opera
Opera
Opera
Opera
Яндекс
Яндекс
Яндекс
Яндекс
ОС
Win
Win
Linux
Linux
Win
Win
Linux
Linux
Язык
RU
ENG
RU
ENG
RU
ENG
RU
ENG
Если дополнительно потребуется протестировать работоспособность в брау-
зере Firefox, то количество сценариев возрастет до 12. Если же приложение будет
иметь четыре разных входных параметра, а каждый из этих параметров три раз-
личных значения, то количество комбинаций будет 3 4 = 81 и потребует создания
и запуска 81 тест-кейса для проверки качества ПО. Для уменьшения количества
тестов и времени, необходимого для тестирования ПО, применяют технику по-
парного тестирования.
Попарное тестирование (pairwise testing) – техника тестирования, в которой
вместо проверки всех возможных комбинаций значений параметров проверяются
только комбинации значений каждой пары параметров [1].Определение из глоссария ISTQB: N-мерное (переборное) тестирование:
разработка тестов методом «черного ящика», при котором тестовые сценарии раз-
рабатываются таким образом, чтобы выполнить все возможные отдельные ком-
бинации любых наборов N входных параметров [2].
Способы получения комбинаций входных параметров [3]:
1. На основе ортогональных массивов;
2. На основе латинских квадратов;
3. IPO (in parameter order) метод;
4. На основе генетических алгоритмов;
5. На основе рекурсивных алгоритмов.
Рассмотрим построение таблицы для попарного тестирования на основе ор-
тогонального массива.
Ортогональный массив – это двумерный массив чисел (таблица), где число
столбцов соответствует числу входных параметров, а каждый параметр может
иметь некоторое количество вариантов значений. При этом столбцы не обяза-
тельно должны иметь одинаковое количество вариантов значений [4].
Таблица обладает следующими свойствами:
1. В каждой паре столбцов будут встречаться все возможные парные комби-
нации значений входных параметров.
2. Если любая пара значений встречается в массиве несколько раз, то все
остальные пары будут встречаться такое же число раз.
Нетрудно видеть, что табл.1 представляет собой ортогональный массив.
Переход от ортогонального массива, описывающего все возможные комби-
нации параметров, к таблице для попарного тестирования иллюстрируется рис.1.
Очевидно, что в сокращенной таблице любая пара столбцов содержит все возмож-
ные комбинации пар значений соответствующих параметров, встречавшиеся в ис-
ходной таблице.
→
Рисунок 1 – Идея преобразованияТак, для ортогонального массива из табл.1 количество реально проводимых
тестов можно уменьшить с восьми до четырех (табл.7.2).
Таблица 2 – Попарное тестирование для кейса
№
1
2
3
4
Браузер
Opera
Opera
Яндекс
Яндекс
ОС
Win
Linux
Linux
Win
Язык
RU
ENG
RU
ENG
Очевидно, что в табл.2 в паре столбцов Браузер-ОС по одному разу встреча-
ются все возможные комбинации их значений, каждая из которых в табл.1 повто-
рялась дважды: Opera-Win; Opera-Linux; Яндекс-Linux; Яндекс-Win.
То же самое можно сказать о комбинациях значений в парах столбцов Брау-
зер-Язык (Opera-RU; Opera-ENG; Яндекс-RU; Яндекс-ENG) и ОС-Язык (Win- RU;
Linux- ENG; Linux-RU; Win- ENG).
Таким образом, с помощью четырех тестов (вместо восьми) мы проверяем
все возможные парные комбинации.
Комбинацию тестов для попарного тестирования генерируют с помощью
специализированных программных продуктов, например, онлайн-инструмента
https://pairwise.teremokgames.com. На рис.2 показана установка входных данных
для генерации тестового набора рассмотренного выше примера. Результаты, ана-
логичные табл.1 и табл.2, скачать в табличном формате.
Рисунок 2 – Установка входных параметров для генерации таблицВыигрыш в количестве тестов при использовании попарного тестирования
увеличивается с ростом количества комбинаций. Так, для приведенного выше
примера (четыре входных параметра, три возможных значения для каждого пара-
метра) попарное тестирование позволяет сократить количество тестов с 81 до 9.
Может показаться, что ограничение количества тестов негативно сказыва-
ется на качестве ПО. Однако практика подтверждает обратное. Высокая эффек-
тивность попарного тестирования объясняется, вероятно, тем, что наиболее рас-
пространенными являются либо одиночные, либо парные дефекты. Попарное те-
стирование как раз и позволяет выявить ситуации, когда ПО не работает при не-
котором значении одного параметра, либо при некоторой комбинации двух пара-
метров.
Следует добавить, что может существовать некоторая комбинация значений
параметров, которая не попала в таблицу попарного тестирования, однако ее про-
верка является критически важной для данного ПО. В этом случае рекомендуется
в дополнение к попарному тестированию создавать тест-кейс, проверяющий ра-
ботоспособность такой комбинации.
Список источников
1.
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. «Системная и про-
граммная инженерия. Тестирование программного обеспечения. Часть 1. Понятия
и определения» URL: https://docs.cntd.ru/document/1200134996 (дата обращения
30.06.2024г).
2.
Глоссарий определений по тестированию, утвержденный Междуна-
родным квалификационным советом по тестированию программного обеспече-
ния (International
Software
Qualifications
Board,
ISTQB)
URL:
https://glossary.istqb.org/ru_RU/search (дата обращения 30.06.2024г).
3.
Тестирование программного обеспечения. Базовый курс: практ. посо-
бие. / С. С. Куликов. — Минск: Четыре четверти, 2015. С. 294.
4.
Беклемишев, Д. В. Курс аналитической геометрии и линейной ал-
гебры: учебник для вузов / Д. В. Беклемишев. – 19-е изд., стер. – Санкт-Петербург:
Лань, 2022. – 448 с.7.4. ТЕСТИРОВАНИЕ СОСТОЯНИЙ И ПЕРЕХОДОВ
Распространенной техникой тест-дизайна на основе тестирования методом
«черного ящика» является тестирование состояний и переходов.
В проекте может быть большой набор требований с описанием состояний
системы и условий перехода между ними. Без визуального представления этих
состояний трудно увидеть всю цепочку событий, что может привести к дефек-
там архитектуры и дизайна приложения на уровне требований.
Кейс. Рассмотрим пример требования. Если у пользователя почтового мес-
сенджера открыты две вкладки браузера с одновременным отображением стра-
ницы с почтой, то на каждой из вкладок должно быть отображено одно и то же
состояние письма: Не прочитано, Прочитано (рис.1), кроме того, письмо может
быть удалено, т.е. исчезнуть из просматриваемой папки.
Рисунок 1 – Состояние письма в разных вкладках
Для отображения объекта, который хранит только один параметр – состоя-
ние, вводят математическую абстракцию или модель дискретного устройства, ко-
торую называют конечным автоматом.
Конечный автомат – алгоритмическая компонента программы «без дан-
ных», моделирующая «инстинктивное» поведение, не адаптируемое к последова-
тельности воздействий внешней среды. Единственным хранимым параметром ав-
томата является его текущее состояние, которое характеризует текущий шаг вы-
полняемого алгоритма.Формы записи конечных автоматов
Предусмотрено две формы записи конечных автоматов.
1. Графическая форма: диаграмма состояний-переходов.
2. Табличная форма, которую используют в программировании и формаль-
ных преобразованиях.
Для человека более наглядным является представление конечных автоматов
в виде диаграммы состояний и переходов. На ее основе специалист по тестирова-
нию сможет составлять тестовые сценарии, основываясь на визуальном представ-
лении состояний и переходов системы.
Основными элементами диаграммы являются:
1. Состояние, которое представляет собой окружность, содержащую номер
или наименование состояния.
2. Направленная дуга, соединяющая состояния Sk и Sm, которая определя-
ется значениями функций переходов и действий (рис.2).
Рисунок 2 – Диаграмма состояний и переходов
Диаграмму состояний и переходов проектируют на основе требований.
Упростим рассматриваемую задачу почтового мессенджера и представим, что
предусмотрено три требования.
Первое требование: сразу после получения сообщений с почтового сервера
они помечены как непрочитанные.
Второе требование: когда пользователь кликает на сообщение, чтобы откры-
лось его содержание, сообщение становится прочитанным.
Третье требование: пользователь может пометить ранее прочитанные сооб-
щения как непрочитанные.Правила проектирования таблицы.
1. Количество строк и столбцов таблицы равно количеству состояний на диа-
грамме (таблица квадратная).
2. Строки соответствуют исходящим стрелкам, столбцы – входящим.
3. Если стрелка выходит из S1 и входит в S2, то на пересечении строки 1 и
столбца 2 следует поставить символ, который будет обозначать выполнение по-
зитивного теста, например «TRUE».
Построим диаграмму состояний и переходов с двумя состояниями, соединен-
ными между собой дугами. Над дугами написаны действия, осуществление кото-
рых переводит из состояния Не прочитано (S1) в состояние Прочитано (S2) и
возвращает из состояния Прочитано в состояние Не прочитано (рис.3).
Рисунок 3 – Пример диаграммы состояний и переходов
Разработаем таблицу для указанных на рис.3 двух состояний и двух дей-
ствий: Прочитать и Вернуть (табл.1). Таблица позволяет показать общее коли-
чество тестов и рассчитать количество позитивных и негативных тестов.
Таблица 1 – Таблица по диаграмме состояний и переходов
СостояниеПрочитано (S1)Не прочитано (S2)
Прочитано (S1)FALSETRUE
Не прочитано (S2)TRUEFALSE
Рассмотрим пример позитивного теста. Позитивные тесты проверяют спо-
собность системы адекватно отреагировать на правильные действия пользователя
или ввод правильных данных. Поэтому ожидаемый результат в примере показы-
вает адекватную реакцию системы на такие действия.Тест-кейс. Проверка действия Вернуть.
1. Открыть список сообщений на двух вкладках браузера.
2. Найти прочитанное сообщение и отметить его непрочитанным на первой
вкладке.
3. Не обновляя вторую вкладку, посмотреть в ней на состояние сообщения,
выбранного на шаге 2.
Ожидаемый результат: сообщение на обеих вкладках отмечено как Не про-
читано.
1.
Список источников
Трофимов, В.В. Алгоритмизация и программирование: учебник для вузов/
В.В. Трофимов, Т.А. Павловская; под редакцией В.В.Трофимова. – 4-е изд. –
Москва: Издательство Юрайт, 2023.– 118 с.7.5. UML-ДИАГРАММА АВТОМАТА
В нотации унифицированного языка моделирования UML, начиная с UML2,
для изображения состояний и переходов некоторого объекта используется диа-
грамма автомата (в более ранних нотациях для нее использовалось название «диа-
грамма состояний»).
Основные графические элементы этой нотации следующие [1]:
Состояние (state) – это ситуация, в которой объект удовлетворяет заданным
условиям, осуществляет некую деятельность или ожидает определенного собы-
тия. В зависимости от состояния реакция объекта на внешние воздействия может
быть различной.
Состояние на диаграмме изображается прямоугольником со скругленными
вершинами. Внутри прямоугольника с заглавной буквы записывается имя состо-
яния, под которым могут указываться действия, выполняемые объектом при
нахождении в данном состоянии. Действия отделяются от имени горизонтальной
чертой.
Каждое из действий записывается в виде отдельной строки и имеет следую-
щий формат:
<метка действия> '/' <выражение действия>
Метка действия может иметь три варианта:
• entry – действие, которое выполняется в момент входа в данное состояние
(входное действие);
• exit – действие, которое выполняется в момент выхода из данного состоя-
ния (выходное действие);
• do – внутренняя деятельность, которая выполняется в течение всего вре-
мени, пока объект находится в данном состоянии.
Пример действия: entry/нажатие кнопки «Регистрация»
Особым образом указываются начальное (черный кружок) и конечное (чер-
ный кружок, обведенный окружностью, иногда называемый «бычьим глазом»)
состояния. Начальное состояние всегда одно, конечных может быть несколько.
Если диаграмма описывает непрерывно работающий автомат, то конечное состо-
яние может отсутствовать.
Переход – это связь между двумя состояниями, означающая, что объект в
первом состоянии должен выполнить определенные действия и перейти во второесостояние, когда произойдет определенное событие или будут выполнены неко-
торые условия.
Событие – это значимое происшествие, локализованного во времени и про-
странстве, которое вызывает переход из одного состояния в другое.
Все переходы обозначаются ребрами или дугами со стрелкой от исходного
состояния к последующему состоянию. Переход может обозначаться вызываю-
щим переход событием, условием выполнения, выполняемым действием. Обозна-
чение перехода должно соответствовать шаблону:
<Событие> (<параметры, разделенные запятыми>) [<граничное усло-
вие>] '/' <Действие>
Здесь граничное (или сторожевое) условие определяет, в каком случае может
быть выполнен переход.
Переход, который инициирован каким-то событием, иногда называют триг-
герным.
После условий может указываться действие – непрерываемое поведение, вы-
полняемое как часть перехода.
Пример:
Отмена билета [Покупатель не произвел оплату в течение суток]/Отме-
нить билет.
UML допускает наличие перехода без вызывающих его событий – это пере-
ход по завершении (или нетриггерный), который происходит по окончанию внут-
ренней деятельности.
С точки зрения теории автоматов такая диаграмма показывает конечный ав-
томат (state machine)
Для реализации UML-диаграмм применяют различные сервисы, в которых
присутствуют элементы и блоки диаграмм, например, онлайн-сервис
https://app.diagrams.net/
Пример диаграммы автомата для бронирования авиабилета представлен на
рис.1.Рисунок 1 – UML-диаграмма автомата для бронирования авиабилета
На основании диаграммы автомата могут быть разработаны сценарии тести-
рования.
Кейс. Рассмотрим задачу тестирования системы бронирования авиабилетов,
UML-диаграмма которой представлена на рис.1. Тестирование всегда начинают с
наиболее часто используемой последовательности событий, чтобы убедиться, что
система работоспособна и выполняет ключевые функции. Если это не так, то
дальнейшее тестирование не имеет смысла до устранения дефектов.
В первую очередь проверяют успешное прохождение основного (наиболее
часто встречающегося) пути бронирования, включая оплату и использование би-
лета (рис.2).Рисунок 2 – Сценарий тестирования основного пути бронирования [2]
1. Точкой старта в этом случае будет вход в систему бронирования и выбор
билета. Затем пользователь вводит информацию, необходимую для бронирова-
ния, и нажимает кнопку «Забронировать». Это нажатие можно считать событием.
Под его воздействием стартует таймер, определяющий время, выделенное для
оплаты. Система переходит в первое состояние «Билет забронирован».
2. Дальнейшее событие – «Оплата», которое переведёт систему в следующее
состояние «Билет оплачен».
3. Затем по событию «Получить билет» система должна выполнить действие
«Отправка билета по e-mail» и перейти в состояние «Билет получен».
4. Последним звеном в этой цепочке будет событие «Предъявлен на по-
садке», которое переводит систему в состояние «Билет использован» – цикл бро-
нирования успешно завершён, система попадает в точку выхода. Заметим, что в
реальных системах бронирования может быть значительно больше событий и со-
стояний.
Не всегда бронирование билета должно заканчиваться его использованием.
Пользователь может не оплатить билет или отменить выполненную оплату и т.п.
Эти состояния также необходимо проверить (рис.3).
Рисунок 3 – Сценарий тестирования альтернативных путей бронирования7.6. ТЕСТИРОВАНИЕ НА ОСНОВЕ
ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ
Для создания программного обеспечения чаще всего используют подход на
основе поведения (Behaviour Driven Development, BDD) и разработку через тести-
рование (Test Driven Development, TDD).
Разработка через тестирование основана на повторении очень коротких цик-
лов [1]. При этом тесты пишут перед написанием очередного фрагмента про-
граммного кода на основе технических требований к нему, затем производят ко-
дирование, после чего сразу проводят тестирование написанного кода. Если тест
пройден, то программный код можно интегрировать в проект.
Основной идеей разработки ПО на основе поведения [2] является совмеще-
ние в процессе разработки технических требований и интересов бизнеса. При та-
ком подходе заказчик ставит перед разработчиками цель, которая сформулиро-
вана в виде конечного ожидаемого процесса в программной системе. Например,
«когда мы фиксируем в системе отправку машины из Москвы, тогда необходимо,
чтобы изменился статус заказа, и было зафиксировано время отправки».
BDD предполагает описание тестировщиком или аналитиком пользователь-
ских сценариев на естественном языке [3] с применением специальных нотаций.
Использование такого подхода позволяет быстро реализовать приемочное тести-
рование, провести сценарное тестирование, тестирование критического пути, ды-
мовое тестирование. В тестировании могут принимать участие пользователи или
специалисты, мало знакомые с программированием, но способные описать дей-
ствия пользователя в виде алгоритма.
При BDD-подходе к разработке процесс реализации задачи начинается не с
написания кода, а с описания тестов к задаче, которую предстоит реализовать.
Тесты формируют на основе пользовательской истории (User Story) [3-4].
Пользовательские истории описывают требуемый функционал разрабатыва-
емого приложения по шаблону:
«Как [персона], я [хочу], [чтобы что]».
Смысл описания должен быть следующим:
Как (As a) [человек, который получает выгоду от функциональности]
Я хочу (I want to) [функциональность]
Чтобы достичь (In order to) [выгода от функциональности]
Рассмотрим примеры таких историй.1. Как посетитель интернет-магазина, я хочу иметь возможность входа в кор-
зину с главной страницы, чтобы быстрее осуществить покупку.
2. Как пользователь веб-приложения по конвертации файлов из .pdf в .docx,
я хочу, чтобы при «зависании» системы несохранённые файлы не терялись.
3. Как студент вуза, я хочу связываться с преподавателем по видеосвязи,
чтобы получать онлайн-консультации.
Каждая User Story отвечает на вопросы, которые следует объединить в одно
предложение:
1. Кто должен выполнить действие с программой?
2. Какое действие он хочет выполнить в программе?
3. Зачем он это делает? Какой результат от нее он хочет получить?
С точки зрения бизнеса понятна цель и запрос, но у разработчика появляются
вопросы, которые нужно объединить в одно предложение. Например, для истории
про посетителя интернет-магазина при осуществлении покупки (рис.1), при раз-
работке ПО следует ответить на вопросы:
1. Как именно должен осуществиться вход?
2. Где должна быть кнопка входа в корзину?
3. Сколько раз на нее должен нажимать клиент?
Рисунок 1 – Размещение кнопки входа в корзину
Поэтому появляется структура сценария тестирования, в которой следует
описать:
– начальные условия;
– событие, которое инициирует начало этого сценария;
– ожидаемый результат или результаты.
Например, последовательность событий при нажатии пользователем на
пиктограмму (кнопка) с корзиной описана следующим сценарием (табл.1).Таблица 1 – Последовательность событий при нажатии на кнопку корзины
Действие пользователяПоследовательность событий
Пользователь
нажимает на кнопку
корзины,
открывается вкладка с
корзиной пользователяКогда пользователь находится на главной странице
магазина <ссылка>
И нажимает на кнопку <наименование кнопки>
То открывается новая страница <ссылка>
И отображается корзина пользователя
Следует обратить внимание на структуру описания последовательности
событий в табл.1 Когда-И-ТО-И, которая используется при написании сценарно-
ориентированных тестов в формате языка Gherkin [5]. Этот формат позволяет
создавать тесты на естественном языке [3] с помощью предметно-
ориентированных нотаций, которые затем преобразуются в автоматические тесты
на языке Python.
Перечислим преимущества техники тестирования на основе пользователь-
ских историй:
‒ Помогает составить план тестирования, структурировав его по разделам на
основе пользовательских историй.
‒ Каждая User Story представляет аналог сценария тестирования с
комплектом тест-кейсов или чек-листов.
‒ Позволяет гибко менять стратегию и план тестирования при изменении
требований клиента.
‒ Помогает сформировать тестовые мероприятия
для приемочного
тестирования.7.7. ТЕСТИРОВАНИЕ НА ОСНОВЕ
ВАРИАНТОВ ИСПОЛЬЗОВАНИЯ
Тест-кейсы могут разрабатываться также на основе UML-диаграммы
вариантов использования (прецедентов).
Диаграмма прецедентов позволяет описать поведение системы с помощью
модели, которая отображает варианты (сценарии) использования, действующих
лиц и связи между ними [1].
Для построения диаграммы прецедентов используются три основных
графических элемента – актор (actor), прецедент (use case) и отношение
(relationship).
Actor (актор, действующее лицо, участник) представляет собой любую
внешнюю по отношению к моделируемой системе сущность, которая взаимодей-
ствует с системой и использует ее функциональные возможности для достижения
определенных целей. По мнению М. Фаулера [2], более правильно было бы в дан-
ном случае использовать термин «роль».
В качестве актора может выступать человек (представленный в некоторой
роли), техническое устройство, другая информационная система или
организация. Так как в общем случае актор всегда находится вне системы, его
внутренняя структура при построении диаграммы не определяется. Имеет
значение только то, как он воспринимается со стороны системы.
Графическим обозначением актора на UML-диаграммах является фигурка
человечка, под которой записывается имя данного действующего лица.
Use case (вариант использования, прецедент) – описание отдельного аспекта
поведения системы с точки зрения пользователя. Прецедент описывает «сервис»,
который система предоставляет актору и благодаря которому пользователь может
получить конкретный, измеримый и нужный ему результат. При этом не
уточняется, как именно достигается результат. Один актор может
взаимодействовать с несколькими прецедентами и наоборот.
Отметим, что термин «Use case» необходимо отличать от «User story».
Также Use case нельзя путать с тест-кейсом. Use case полностью описывает
некоторый функционал системы. Тест-кейс является более узким понятием,
которое включает только тестирование конкретной функции или возможности
системы.
Прецеденты обычно применяются для спецификации внешних требований к
системе.Графическим обозначением прецедента является эллипс, внутри которого
содержится его название. В качестве названия прецедента может использоваться
либо короткая глагольная форма, либо существительное, отражающее
происходящие внутри него процессы.
Основная цель вариантов использования заключается в том, чтобы
зафиксировать требуемое поведение системы с точки зрения конечного
пользователя для достижения одной или нескольких желаемых целей. Вариант
использования содержит описание потока событий, который показывает
взаимодействие между акторами и системой.
Поток событий – последовательность событий, необходимых для
обеспечения требуемого поведения. Поток событий описывается текстом на
языке предметной области, а не терминами реализации проектируемой системы.
Поэтому такое описание понятно и разработчику и заказчику.
Каждый вариант использования должен быть задокументирован. Для этого
может применяться шаблон, разработанный сообществом бизнес-аналитиков в
России на основе BABOK Guide (Business Analysis Body of Knowledge -
руководство к своду знаний по бизнес-анализу) [3]. Пример заполненного
шаблона предствлен в табл.1.
Таблица 1 – Пример заполнения шаблона варианта использования
ID Варианта использо- ID1
вания:
Наименование варианта Создать учетную запись пользователя в интернет-ма-
использования:
газине
Кем создан:
Кем в последний
раз изменен:
Дата создания:
Дата последнего
изменения:
Акторы:
Пользователь (при указании нескольких акторов они
могут быть разделены на главных и второстепенных)
Описание:
Основной поток событий: Пользователь через браузер
получает гостевой (не требующий регистрации и име-
ющий ограниченный функционал просмотра страниц)
доступ по соответствующему URL и взаимодействует
с представленной функциональностью.Предварительные усло- Веб-браузер открыт и получен гостевой доступ поль-
вия:
зователя к веб-приложению интернет-магазина.
Постусловие:
1. Система при успешной регистрации обновляет дан-
ные в базе данных пользователей.
2. Система при успешной регистрации отправляет на
указанный пользователем электронный адрес элек-
тронное письмо, содержащее логин и пароль.
Нормальный ход собы- 1. Прецедент начинается, когда пользователь выби-
тий:
рает опцию «создать новую учетную запись».
2. Система просит пользователя ввести ФИО, адрес
электронной почты, пароль и подтверждение пароля
(путем повторного набора).
3. Система проверяет корректность введенных данных
4. Система создает новую учетную запись.
5. Система подключает пользователя к странице авто-
ризации (с предложением ввода логина и пароля)
Альтернативный
ход 1. Пользователь не заполнил поля, соответствующие
событий:
ФИО
2. Пользователь указал некорректный адрес электрон-
ной почты
3. Повторный набор пароля не совпадает с первичным
4. Пользователь отказался от регистрации и нажал
кнопку «Выход».
Исключения:
База данных клиентов недоступна (например, из-за
длительного времени заполнения формы регистра-
ции). Система выводит сообщение о невозможности
создания учетной записи и просит повторить ввод
данных.
Содержит:
Приоритет:
Высший
Частота использования: Одно использование на одно гостевое посещение
Бизнес-правила
Будут определены позднее
Специальные требова- Доступ 24/7
ния:Предпосылки (предпо-
ложения):
Примечания и вопросы:
Создать учетную
запись
Пользователь
Графическое представление варианта использования
Рассмотрим рекомендации по заполнению основных разделов шаблона.
ID Варианта использования – рекомендуется присвоить каждому варианту
использования уникальный числовой идентификатор в иерархическом формате,
что позволяет упростить работу при большом количестве прецедентов.
Наименование варианта использования – ориентированное на результат имя
в краткой форме должно отражать задачи, которые пользователь может
выполнить с помощью системы. Рекомендуется включать в наименование глагол
и существительные, например: «Просмотреть информацию по номеру заказа».
Актор – имена акторов, которые будут выполнять этот вариант
использования. Имя должно быть достаточно информативным с точки зрения
функционала актора, например, пользователь, продавец, менеджер.
Описание – формулировка причины и результатов варианта использования
или высокоуровневое описание последовательности действий и результата
выполнения варианта использования. Соответствующий пример представлен в
табл.1 (в шаблоне).
Предварительные условия – мероприятия или условия, которые должны быть
выполнены, прежде чем начнет выполняться данный вариант использования.
Например, предусловием может быть выполнение другого варианта
использования или прохождение пользователем процедуры идентификации.
Отметим, что предварительные условия бывают не у всех вариантов
использования.
Диаграммы вариантов использования не должны отражать порядок их
выполнения во времени. Однако предварительные условия позволяют
документировать и такую информацию. Например, предусловием одного
варианта использования может быть то, что одновременно должен выполняться
другой прецедент.Постусловия – условия, которые всегда должны быть выполнены после
завершения данного варианта использования. Постусловия бывают не у каждого
варианта использования. Как и предварительные условия, постусловия позволяют
неявным
образом
документировать
последовательность
выполнения
прецедентов.
Потоки событий бывают трех типов: основной (нормальный),
альтернативный и поток ошибок или исключений.
Нормальный ход событий – наилучший либо наиболее часто используемый
путь исполнения прецедента в нормальных, ожидаемых условиях. Итогом этих
действий должно быть достижение цели, которая указана в названии варианта
использования и в его описании. Рекомендуется делать описание хода событий в
виде нумерованного списка действий, которые выполняет актор, чередуя их с
реакциями системы на производимые действия.
Альтернативный поток описывает отклонения от основного потока,
которые могут иметь место в пределах данного варианта использования и не
рассматриваются как ошибочные.
На основе описания нормального и альтернативного потока событий с
учетом предусловий и постусловий разрабатывают сценарии позитивного
тестирования.
Исключения или поток ошибок рассматриваются как отклонения от
нормального или альтернативного хода событий, которые могут возникнуть во
время их выполнения. Здесь необходимо определить, как система должна
отреагировать на эти отклонения, а также на завершение варианта использования
по какой-либо непредвиденной причине.
Следует отметить, что для каждого из перечисленных при
документировании альтернативных вариантов использования должно быть
составлено описание по аналогичному шаблону.
Альтернативный поток и поток исключений в конкретном прецеденте могут
отсутствовать, в этом случае их описание не приводится.
В пункте «Содержит» перечисляются (в случае их наличия) любые другие
варианты
использования,
которые
вызываются
данным
вариантом
использования.
Графическое представление варианта использования может содержать
необходимый фрагмент будущей UML-диаграммы прецедентов.О заполнении остальных пунктов можно прочитать в документации к
шаблону по ранее указанной ссылке.
В языке UML существует несколько стандартных видов отношений
(relationship), описывающих взаимодействие между акторами и прецедентами:
– ассоциации (association relationship);
– расширения (extend relationship);
– включения (include relationship);
– обобщения (generalization relationship).
Условные обозначения отношений на диаграммах представлены в табл.2.
Таблица 2 – Условные обозначения отношений между акторами и прецедентами
Отношение
ассоциации (association)
обобщения (generalization)
Условное обозначение
включения (include) или расши-
рения (extend)
Отношение ассоциации устанавливает, какую конкретную роль играет актор
при взаимодействии с экземпляром прецедента. Ассоциация не обязательно
должна быть бинарной: один актор может быть связан как с одним, так и с
несколькими прецедентами, а один прецедент – с несколькими акторами.
Отношение ассоциации обозначается сплошной линией между актором и
прецедентом. Могут использоваться дополнительные обозначения: направление
связи, кратность концевых точек ассоциации, наименование связи.
Направление связи показывается в виде стрелки при необходимости
указания того, кто является инициатором. Если отношение направлено от актора
к прецеденту, то это означает, что именно актор инициирует выполнение
прецедента. В этом случае актора иногда называют главным актором, а актора-
получателя информации о результатах функционирования системы –
второстепенным актором.
Отношения включения и расширения определены только между
прецедентами.
Включение (include) означает, что базовый прецедент включает в себя другой
прецедент. Включаемый прецедент никогда не существует автономно, а только
как часть базового прецедента. Можно считать, что базовый прецедент
заимствует поведение включаемых.Возможен случай, когда несколько базовых прецедентов имеют общий
включаемый прецедент.
Включение графически изображается в виде пунктирной стрелки с надписью
<<include>>, которая направлена от базового элемента к включаемому (рис.1).
Заказ товара
<<include>>
Оплата заказа
Рисунок 1 – Обозначение отношения включения
Расширение (extend) показывает, что целевой прецедент расширяет
поведение исходного (базового). Функциональное поведение целевого
прецедента задействуется базовым не всегда, а только при выполнении некоторых
дополнительных условий.
Графически расширение изображается пунктирной стрелкой с надписью
<<extend>>, направленной от используемого прецедента к базовому (рис.2).
Оформить
продажу
<<extend>>
Предоставить
скидку
Рисунок 2 – Обозначение отношения расширения
Отношение обобщения может иметь место как между прецедентами, так и
между акторами. Это структурное отношение типа «наследование», которое
показывает, что объект-потомок наследует структуру и поведение родителя.
Для акторов отношения обобщения не обязательны. Они нужны только если
поведение одного актора отличается от поведения другого, причем это
затрагивает систему. Если же и родитель и потомок используют одни и те же
прецеденты, то показывать обобщение не требуется.
Отношение обобщения для прецедентов означает, что один прецедент
является частным выражением другого, и прецедент-потомок может быть
подставлен везде, где появляется его родитель, но не наоборот.
Графически данное отношение обозначается сплошной линией со стрелкой в
форме незакрашенного треугольника, которая направлена от частного элемента к
общему (рис.3).Оплатить налич-
ными
Оплатить
заказ
а)
Кладовщик
Сотрудник
б)
Рисунок 3 – Обозначение отношения обобщения
а ‒ между прецедентами,
б ‒ между акторами
Обычно построение диаграммы прецедентов для некоторой системы
выполняется в следующей последовательности:
1. Определяются границы подлежащей моделированию части системы (или
системы в целом).
2. Определяются действующие лица и особенности их взаимодействия с
моделируемой системой. Поскольку акторы по определению находятся вне сферы
деятельности системы, моделирование связей между ними диаграммой
прецедентов не предусмотрено. При необходимости могут указываться только
отношения обобщения.
3. Описывается, какой функционал (варианты использования) ожидается от
системы. Для этого целесообразно идентифицировать все внешние события, на
которые система должна отреагировать. Каждый вариант использования должен
быть инициирован актором. Отношения ассоциации, особенно направленной,
между вариантами использования не применяются, т.к. описание порядка
выполнения прецедентов данным типом диаграмм не предусмотрено.
4. Производится составление диаграммы прецедентов, которое может
сопровождаться составлением словаря предметной области или его дополнением
понятиями, необходимыми для описания прецедентов.
Пример диаграммы прецедентов представлен на рис.4.Рисунок 4 – Диаграмма прецедентов для офиса продаж
Для более подробного представления системы допускается построение
вспомогательных диаграмм прецедентов. При этом любой из прецедентов может
быть подвергнут дальнейшей декомпозиции на множество подвариантов
использования отдельных элементов, которые образуют исходную сущность.
1.
2.
3.
Список источников
Аграновский, А.В. Универсальные средства визуального моделирования ин-
формационных транспортных систем: учебно-методическое пособие / А.В.
Аграновский; С.-Петерб. гос. ун-т аэрокосм. приборостроения. – Санкт-Пе-
тербург : Изд-во ГУАП, 2023. – 48 с.
Фаулер, М. UML. Основы : Краткое руководство по стандартному языку объ-
ектного моделирования / М. Фаулер. - 3-е изд. - СПб. : Символ, 2014. - 192 с.
Шаблон документа с бизнес-требованиями. URL: https://analytics.in-
fozone.pro/document-template-with-business-requirements/ (дата обращения
30.06.2024г).7.8. ИССЛЕДОВАТЕЛЬСКОЕ ТЕСТИРОВАНИЕ
Определение исследовательского тестирования приведено в [1]:
Исследовательское тестирование (exploratory testing) – тестирование,
основанное на опыте, при котором тестировщик спонтанно разрабатывает и
выполняет тестирования на основе существующих соответствующих знаний
тестировщика, предшествующих исследований элемента тестирования (включая
и результаты предыдущих тестирований) и эвристических «эмпирических
правил» для общего поведения программного обеспечения и типов отказа.
Примечание – исследовательское тестирование направлено на выявление
скрытых свойств (включая и скрытое поведение), которые сами по себе, с одной
стороны, вполне возможно, безобидны, но, с другой стороны, могут повлиять на
другие свойства тестируемого программного обеспечения и тем самым увеличить
риск того, что программное обеспечение перестанет работать.
В глоссарии ISTQB [2] указано, что исследовательское тестирование –
подход к тестированию, согласно которому тестировщики динамически
проектируют и выполняют тесты, основываясь на своих знаниях, исследовании
тестируемого элемента и результатах предыдущих тестов.
Таким образом, при
проведении исследовательского тестирования
ключевыми факторами становятся пользовательский опыт специалиста по
тестированию, его профессиональные компетенции и интуиция, а также личная
ответственность за проведение тестовых мероприятий.
В ходе проведения данного тестирования находят неожиданные дефекты, о
существовании которых невозможно было предположить при составлении
тестового плана, и по этой причине не были предсмотрены соответствующие тест-
кейсы. При исследовательском тестировании разработка новых тестов основана
на интуиции тестировщика и результатах ранее проведенных тестов. Такой
подход позволяет гибко выбирать сценарии тестирования и адаптировать их под
конретные задачи. При этом тестировщик в ходе процесса тестирования может
отклоняться от задуманного им процесса тестирования.
В ходе исследовательского тестирования специалист по тестированию
проводит тестирование по определенной траектории, базовые положения которой
описаны Дж. Бахом (J.Bach) в профессиональном блоге о тестировании [3]:
1. Определяет цель тестирования.
2. Устанавливает ограничения для проведения тестирования, например,
проверку только основного функционала, который можно описать сиспользованием пользовательской истории: «Как посетитель интернет-магазина
я хочу иметь возможность входа в корзину с главной страницы, чтобы быстрее
осуществить покупку».
3. Обдумывает тактику тестирования, определяет, какие характеристики ПО
необходимо обязательно проверить, и планирует время, отведенное на тестирова-
ние.
4. Определяют артефакты тестирования, чаще всего к ним относят тестовые
сценарии, отчеты по дефектам и отчеты по тестированию.
Исследовательское тестирование проводят на основе различных подходов. В
частности, к ним относят туры Джеймса Виттакера (James A. Whittaker), которые
он описал в книге «Exploratory Software testing» [4]. В книге предложено
посмотреть на тестируемое ПО, как на незнакомый город, и проводить
тестирование с позиции туриста, который хочет познакомиться с ним. Название
туров подсказывает, какие типы дефектов можно обнаружить, если выполнять
предписанную последовательность шагов.
Например, группа туров по деловому центру (Tours of the Business District)
проверит ту функциональность приложения, которая привлекает пользователя. К
турам этой группы относят (в переводе О.Назиной) [5]:
1. Тур по путеводителю (The Guidebook Tour).
2. Денежный тур (The Money Tour).
3. Тур по ориентирам (The Landmark Tour).
4. Интеллектуальный тур (The Intellectual Tour).
5. Внеурочный тур (The After-Hour Tour).
6. Тур сборщика мусора (The Garbage Collector Tour).
Кейс. Рассмотрим тур по путеводителю для платформы ЛЭТИ (https://etu.ru/).
Как правило, в путеводителе описаны основные маршруты путешествия по
городу. Именно они станут сценариями тестирования. При этом погружаться в
сложную иерархию веб-системы не следует.
1. Определение пользователй интернет-представительства вуза: школьники,
поступающие, обучающиеся, сотрудники, выпускники (рис.1).Рисунок 1 – Определение целевой аудитории
2. Выясненение структуры и сфер деятельности вуза: университет,
образование, наука, сотрудничество, вне учебы (рис.1).
3. Просмотр основной информации о вузе в футере главной страницы (рис.2):
разделы платформы, сгрппированые по определенным признакам, ссылки на
социальные сети и др.
Рисунок 2 – Группировка ссылок в футуре
Предположим, что тестировщик проверяет работоспособность платформы
вуза с позиции поступающего. Тогда дальнейший ход тестирования связан с
проверкой этой функциональности.
Нажатие в меню на вкладку Поступающие переводит на веб-страницу
Приемной комиисии ЛЭТИ, на которой абитуриент выбирает желаемый уровеньобучения: бакалавриат и специалитет, магистратура, аспирантура. Отдельно
выделены мероприятия, довузовская подготовка и контакты (рис.3).
Рисунок 3 – Выбор траектории обучения
Продолжение тура по странице приемной комиссии позволяет
познакомиться с направлениями подготовки, вопросами при поступлении,
необходимыми документами (рис.4).
Рисунок 4 – Информация о поступлении
Таким образом, мы провели исследовательское тестирование пути
абитуриента по платформе ЛЭТИ.Исследовательское тестирование похоже ad-hoc тестирование, под которым
понимают тестирование на основе импровизации, без использования специфика-
ций, планов и разработанных тест-кейсов. При исследовательском тестировании
разработка новых тестов основана на интуиции тестировщика и результатах ранее
проведенных тестов.
1.
2.
3.
4.
5.
Список источников
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. «Системная и программная
инженерия. Тестирование программного обеспечения. Часть 1. Понятия и
определения» URL: https://docs.cntd.ru/document/1200134996 (дата обраще-
ния 30.06.2024г).
Глоссарий определений по тестированию, утвержденный Международным
квалификационным советом по тестированию программного обеспече-
ния (International Software Qualifications Board, ISTQB) URL: https://glos-
sary.istqb.org/ru_RU/search (дата обращения 30.06.2024г).
Bach J., Bolton M. Exploratory Testing 3.0 URL:
https://www.satis-
fice.com/blog/archives/1509 (дата обращения 30.06.2024г).
James A. Whittaker. Exploratory Software Testing: Tips, Tricks, Tours, and Tech-
niques to Guide Test Design Publisher: Addison-Wesley Professional; 1st edition
(September 4, 2009) – 252 p.
Назина О. Переводы туров для исследовательского тестирования URL:
https://www.software-testing.ru/library/testing/testing-for-beginners/2965-explor-
atory-software-testing (дата обращения 30.06.2024г).7.9. ТЕСТИРОВАНИЕ НА ОСНОВЕ ЭВРИСТИК И ОРАКУЛОВ
Тестирование на основе эвристик и оракулов основано на восприятии
информации и способах ее обработки человеческим сознанием. Д. Канеман
предложил основываться на двух способах познания: интуиции и рассуждениях
[1]. Интуиция основана на ассоциативных и эмоциональных связях, привычных
действиях, часто предполагает предварительное ознакомление с моделями
решения задач. Рассуждения базируются на опыте человека и его логике.
При тестировании применяют оба подхода. Если тестовые мероприятия
разрабатывают на основе интуиции, то их называют эвристиками [2]. Если
тестировщик предварительно продумывает возможное место нахождения
дефекта и может объяснить причины его появления, то такой подход называют
оракулом.
Приведем примеры. Предположим, что мы совершаем покупку в интернет-
магазине. Ранее другой покупатель показал нам, каким образом может быть
проведена онлайн-оплата с помощью карты «Мир». При совершении
самостоятельной покупки в другом интернет-магазине мы просто повторим уже
известные действия. В этом случае будет использован подход на основе эвристик.
Если карта платежной системы «Мир» отсутствует, то пользователь должен
предварительно продумать все возможные сценарии оплаты: наличными при
получении, задействовать другую банковскую карту и другие. Это – подход на
основе оракула. Больше примеров можно найти в статье К. Клоки (Katrina Clokie)
[3].
К известным в среде тестировщиков эвристикам [4] относят эвристику по
сказке с английскими корнями «Три медведя», которая описана Э.Хендриксон
(Elisabeth Hendrickson) в книге [5].
Эта эвристика основана на концепции «слишком мало, слишком много и в
самый раз». Например, при тестировании поля ввода фамилии при регистрации
личного кабинета тестировщик может ввести 1 символ, 1000 символов или 25
символов. Также нужно попробовать ввести числовые данные и данные в
смешанном формате.
Для лучшего запоминания предназначения эвристик и оракулов создают
мнемоники. Мнемоника – это совокупность приёмов, облегчающих процесс
запоминания и увеличивающих объём запоминаемой информации. Важно
отметить, что не каждая эвристика имеет мнемонику.Тестирование с использованием мнемоник
При тестировании используют мнемоники, которые позволят запомнить,
какой функционал приложения следует протестировать [6]. В них нет четких
инструкций, они служат памятками для того, чтобы не забыть провести тестовые
мероприятия в определенной сфере [4].
Например, оракул тестирования FEW HICCUPPS, в переводе «небольшие
проблемы», описан М. Болтоном и Дж. Бахом [7]. Этот оракул предназначен для
понимания тестировщиком поведения тестируемого приложения и определения,
является ли такое поведение дефектом или нет. Оракул используют, если
спецификация на ПО отсутствует или содержит неадекватную информацию.
Рассмотрим расшифровку мнемоники FEW HICCUPPS [8]:
Familiarity – родственность, осведомленность. Продукт не содержит
известных багов, которые можно встретить в других схожих ПО. Например, поле
для ввода логина учитывает возможность введения пробелов.
Explainability – объяснимость. Программное обеспечение понятно
пользователю. Предположим, проходит тестирование онлайн-калькулятора по
выдаче кредита под определнный процент. Пользователь вводит количество
своих полных лет, доход на одного члена семьи и ему автоматически
расчитывают ставку по кредиту без объяснения причин размера ставки.
World – мир. Продукт соответствует тому, что мы знаем или можем
наблюдать в мире, например, законам физики или правилам математики. Так,
расстояние между двумя точками, построенными в программе-навигаторе, не
должно быть отрицательным.
History – история. Текущая версия системы поддерживает преемственность
функционала предыдущих версий и пользователю не требуется переучиваться для
взаимодействия с приложением.
Image – имидж. Репутация и имидж компании. Например, при тестировании
веб-приложения фотогалереи внимательно оценивают качество представленных
там фотографий.
Comparable product – конкуренты. Программное обеспечение не хуже, чем
аналогичные продукты. Например, в интернет-магазине можно отфильтровать
товары по желанию пользователя.
Claims – требования. Продукт соответствует тому, что указано в требованиях
заказчика. Например, запрос к базе данных обрабатывается не более, чем 7
секунд.User Expectations – потребности пользователя. Программное обеспечение
отвечает потребностям конечных пользователей.
Product – продукт. Все элементы продукта реализованы в едином стиле.
Например, для закрытия окна с приложением можно нажать на пиктограмму
крестика в верхнем правом углу окна.
Purpose – цель. Система реализует поставленную цель и соответствует
назначению.
Standards – стандарты. Программное обеспечение соблюдает законы или
постановления, относящиеся к продукту или его использованию.
Рассмотрим еще две мнемоники:
1. RIMGEA – мнемоника для описания дефектов от Cem Kaner
(http://kaner.com/). «Replicate it, Isolate it, Maximize it, Generalize it, Externalize it,
And Say it Clearly and Dispassionately», т.е. «Воспроизведи это, Изолируй это,
Увеличь до максимума, Обобщи, Сделай вывод, Скажи о дефекте максимально
ясно и четко».
2. RCRCRC – эвристика для регрессионного тестирования от Karen N.
Johnson (https://www.karennjohnson.com/). «Recent, Core, Risk, Configuration,
Repaired, Chronic».
Recent – Какие новые функции были добавлены в текущей итерации, что
было изменено в уже существующем функционале.
Core – Основные сценарии. Что должно всегда работать?
Risk – Какой функционал имеет максимальные риски? Его и проверяем.
Configuration – На каких окружениях и в каких конфигурация должно
работать?
Repaired – Какой функционал мы чинили в релизе? Ретест ранее
обнаруженных багов, как минимум, самых важных
Chronic – Регрессиионное тестирование областей, где чаще всего находились
дефекты.
Мнемоники в тестировании придумывают для решения конкретных задач.
Их список постоянно расширяется. Каждый тестировщик может придумать свою
мнемонику.Тестирование на основе чек-листов и чит-листов
При тестировании часто используют эвристики в формате чек-листов и чит-
листов.
Чит-лист (Cheat-sheet) – это список универсальных проверок. Пример чит-
листа регистрации нового пользователя показан в [9].
Рассмотрим пример чит-листа для проверки формы ввода текста, в
частности, фамилии пользователя:
– Ввод
на
кириллице/латинице;
регистр
букв
верхний/нижний/комбинированный.
– При вводе чисел выдается ошибка/ввод чисел невозможен.
Чек-лист (Checklist) – это список возможных проверок. Его можно составить
в табличном формате, который, например, содержит следующие столбцы:
название, описание проверки, приоритет проверки, отметка о выполненных
действиях (Passed/Failed), заметки и комментарии. Структуру чек-листа
определяет корпоративный стиль ведения документации.
Рассмотрим пример чек-листа для проверки формы ввода фамилии
пользователя:
1. Поле может принимать только символы кириллицы и латиницы.
2. Поле не позволяет вводить специальные символы, такие как знаки
препинания, скобки и т. д.
3. Поле не допускает ввод чисел.
4. Максимальная длина поля соответствует требованиям технического
задания (фамилия может состоять из одной или нескольких букв, одного или
нескольких слов, включая написание через дефис).
5. При попытке ввести недопустимые символы пользователь получает
соответствующее сообщение об ошибке.
6. Поле работает корректно при различных браузерах и размерах экрана.
Чек-лист и чит-лист принято дополнять в зависимости от конкретных
требований проекта.
Применение чек-листов и чит-листов повышает производительность
процесса тестирования, уменьшает количество невыполненных тестов, упрощает
процесс делегирования за счет передачи коллегам списков возможных проверок
ПО.1.
2.
3.
4.
5.
6.
7.
8.
9.
Список источников
Kahneman, D. (2003). A perspective on judgment and choice: Mapping bounded
rationality.
American
Psychologist,
58(9),
697–720
URL
https://psycnet.apa.org/doiLanding?doi=10.1037%2F0003-066X.58.9.697 (дата
обращения 30.06.2024г).
Мерц Дж. Эвристики функционального тестирования: системный взгляд.
URL: https://software-testing.ru/library/testing/functional-testing/2349-function-
altestingheuristics (дата обращения 30.06.2024г).
Клоки, К. Эвристики и оракулы URL: https://www.software-testing.ru/li-
brary/testing/general-testing/2364-heuristics-and-oracles
(дата
обращения
30.06.2024г).
Брэдшоу Р., Дири С. Эвристики тестирования: будьте внимательны! URL:
https://software-testing.ru/library/testing/test-analysis/3308-software-testing-heu-
ristics-mind-the-gap (дата обращения 30.06.2024г).
Hendrickson E. Explore It!: Reduce Risk and Increase Confidence with Explora-
tory Testing. – изд. O′Reilli, 2013. –160 p.
Lynn McKee. Mnemonics URL: https://www.qualityperspectives.ca/re-
sources/#mnemonics (дата обращения 30.06.2024г).
Bach
James.
FEW
HICCUPPS.
URL:
https://de-
velopsense.com/blog/2012/07/few-hiccupps (дата обращения 30.06.2024г).
Киселева О. Мнемоники в тестировании URL: https://okiseleva.blog-
spot.com/2018/11/blog-post_4.html (дата обращения 30.06.2024г).
Лупан А. Пример чит-листа URL: http://wiki.software-testing.ru/Чит-
ист_регистрации_от_Алексея_Лупана (дата обращения 30.06.2024г).8. Отчет о дефектах
«Днём рождения» первого компьютерного бага считается 9 сентября 1945г.
В Гарвардском университете в то время работал небольшой компьютер «Mark
II». В этот день с машиной возникли проблемы. Исследование показало, что
мотылёк попал между контактами реле №70 в панели F1. Операторы извлекли
мотылька и сделали соответствующую запись в журнале: «Обнаружен первый
настоящий баг» (рис.1). От английского слова «bug» – жук, насекомое.
Рисунок 1 - Фиксация первого в истории бага
К определениям, которым часто используют тестировщики относят следу-
ющие.
Дефект – это несоответствие требованиям или функциональным специфи-
кациям.
Также следует помнить, что к багам относится любое некорректное поведе-
ние программы, не соответствующее оправданным ожиданиям пользователя,
даже в том случае, если это поведение не документировано в требованиях и спе-
цификациях. Баги могут встречаться в любой документации, в архитектуре и ди-
зайне, в коде программы и т.д.
Иногда баг на самом деле является не ошибкой в программе, а результатом
неверного конфигурирования программы и/или окружения.
При приеме на работу QA-инженерам уточняют понимание у претендентов
разницу в понятиях.
1
Смитсонианский национальный
URL:https://www.si.edu/
музей
американской
истории,
ВашингтонBug (баг) – это ситуация, возникающая, когда продукт (приложение) не со-
ответствует утвержденным ранее требованиям.
Если где-то в коде допущена ошибка, она провоцирует «поломку» кода, и
приложение работает некорректно. Такую ситуацию тестировщики называют
багом. Найденный баг может быть воспроизведен, то есть воссозданы условия,
при которых он возникает.
Defect (дефект) — Несовершенство или недостаток рабочего продукта,
проявляющееся в несоответствии требованиям или спецификациям2 ( по ISO
24765).
В ГОСТ 56920 зафиксировано: Ошибки или допущенные дефекты обычно
имеют место и неизбежны. Опечатка или ошибка, сделанная человеком, приво-
дит к возникновению дефекта в продукте, над которым человек работает
(например, спецификация требований или компонент программного обеспече-
ния). Дефект не оказывает влияния на функционирование программного обеспе-
чения до тех пор, пока он не будет обнаружен при эксплуатации программного
обеспечения. Однако если дефект обнаружен в реальных условиях, когда про-
дукт уже сдан в эксплуатацию, то это может привести к тому, что продукт не
будет удовлетворять законным потребностям пользователя3.
Error (ошибка) – Действие человека, которое приводит к неправильному
результату ( по ISO 24765).
Fault (сбой) – ситуация, когда приложение не может правильно функцио-
нировать. Например, из-за недостатка свободной памяти или места на диске, или
невыполнения каких-то нужных действий.
Failure (отказ) –событие, при котором компонент или система не выпол-
няют требуемую функцию в соответствии со спецификацией ( по ISO 24765).
Отчет о дефекте – это документирование возникновения, характера и со-
стояния дефекта. В глоссарии ГОСТа 56920 присутствует понятие отчета об ин-
циденте - отчет об инциденте (Incident Report): Документация по инциденту о
его проявлении, природе и состоянии.
Отчёт о дефекте и вместе с ним сам дефект проходит определённые стадии
жизненного цикла (рис.2).
2
24765-2017 - Международный стандарт ISO/IEC/IEEE. Системная и программная инженерия. Словарь. URL:
https://ieeexplore.ieee.org/document/8016712
3
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013 СИСТЕМНАЯ И ПРОГРАММНАЯ ИНЖЕНЕРИЯ. Тестирование
программного обеспечения. Часть 1. Понятия и определения.Рисунок 2- Жизненный цикл дефекта
Стрелками соответствующих цветов показано выполнение работы над де-
фектом разными участниками процесса. В прямоугольниках показаны различ-
ные статусы -состояния дефекта. Отчет о найденном дефекте создают тестиров-
щики. Затем описание дефекта проверено руководителем команды тестировщи-
ков или тест-менеджером. После проверки отчет считают открытым. Для ис-
правления дефекта назначают разработчика. Он пробует воспроизвести дефект
по сценарию, описанному тестировщикам. Если дефект воспроизведен, то раз-
работчик начнет работы по его устранению. Если воспроизвести не удается, то
отчет будет отклонен и затем повторно проверен тестировщиком. После исправ-
ления дефекта также передают задачу тестировщику для повторной проверке. В
случае успешного выполнения тестирования дефект закрывают.
Отчёт о дефекте
Отчёт о дефекте – это документ, описывающий ситуацию или последова-
тельность действий приведшую к некорректной работе объекта тестирования, с
указанием причин и ожидаемого результата.- это документ, описывающий ситу-
ацию или последовательность действий приведшую к некорректной работе объ-
екта тестирования, с указанием причин и ожидаемого результата.
Назначение отчета:
1.
Предоставление информации об инциденте
2.
Определение степени влияния на систему
3.
Содействие устранению проблемы
Правило составления отчетаОсновное правило составления отчета о дефекте в том, что на каждый де-
фект должен быть составлен отчет (рис.3) .
Рисунок 3 - Правило составление отчета о дефекте
Все отчеты создают в системе по управлению дефектами, к которой есть
доступ у коллег по работе. Основная цель написания отчёта об ошибке – устра-
нение ошибки.
Поэтому стоит помнить, что хороший тестировщик – не тот, кто написал за
день 1000 бесполезных и бессмысленных отчётов, а тот, по чьим отчётам, вне
зависимости от их количества, было исправлено большое количество ошибок4.
Отчеты о дефектах создают:
1.
тестировщики и специалисты по обеспечению качества,
2.
разработчики,
3.
представители службы технической поддержки,
4.
продавцы и специалисты по маркетингу,
5.
представители заказчика,
6.
конечные пользователи.
Отчет о дефекте имеет следующую структуру:
1. Уникальный номер присваивают каждому баг-репорту при введении за-
дачи в системы по отслеживанию дефектов..
2. Заголовок кратко объясняет, что произошло. По нему можно понять
суть ошибки, не читая весь отчёт.
3. Шаги воспроизведения показывают алгоритм или пошаговую инструк-
цию, как воспроизвести баг.
4. Результаты описывают расхождение между тем, что должно быть и что
получилось.
5. Окружение уточняет, в каких операционных системах и браузерах воз-
никла ошибка.
4
Тестирование программного обеспечения. Базовый курс: практ. пособие. / С. С. Куликов. — Минск: Четыре
четверти, 2015. С. 2946. Важность дефекта акцентирует внимание на степень его влияния на си-
стему
7. Приоритет показывает, как быстро дефект должен быть устранён
8. Предусловие показывает, что надо сделать до шагов воспроизведения.
Указывают, когда нужно корректировать настройки, менять параметры
перед шагами.
9. Постусловие уточняет, требуется ли вернуть в прежний вид после те-
стирования.
10. Дополнительные материалы помогают проиллюстрировать баг. Бывает
так, что дефект сложно описать словами или ошибка комплексная, и по
шагам в ней разобраться трудно, поэтому проще сделать скриншот или
записать видео, показать логии (рис.4).
Рисунок 4-Пример дополнительного материала
Важным атрибутом отчета о дефекте является заголовок. Он должен исчер-
пывающе описывать проблему. Важно, чтобы коллеги сразу поняли суть про-блемы, не вникая в детали отчёта. Заголовок предоставляет краткую и в то же
время достаточную для понимания сути дефекта информацию.
Структура заголовка проста. Заголовок должен отвечать на ТРИ вопроса:
что? где? когда? (рис.5). В заголовке описывают фактический результат, то есть
то, что увидел тестировщик.
Рисунок 5 -Структура заголовка отчета о дефекте
Примеры заголовков:
1. Файл с именем длиннее 50 символов система не открывает.
2. Ссылка Заказы на главной странице переадресует на страницу Контакты
3. Не попасть в площадь кнопки Отправить в футуре (очень маленькая зона
клика)
Если возникают затруднения в написании заголовка, то используют сервис
http://bugred.ru/ для поиска вдохновения и правильного решения.
Классификация по степени влияния на систему
Дефекты различают по степени влияния на систему – серьёзности (табл.1).
Таблица 1 - Градация серьезности дефектов
Обозначение Степень серьезности
S1
Блокирующая
(Blocker)
S2
Описание
Дефект приводит к невозможности за-
вершить выполнение бизнес-процесса;
Дефект приводит к непреднамеренному
завершению работы системы, либо к не-
возможности запустить систему;
Бизнес-процессы реализованы неверно.
Для функционирования тестируемой
web-системы требуется срочное исправ-
ление дефекта.
Не существует точек входа, позволяю-
щие обойти дефект.
Пример. Дом построен. В него нельзя
войти. Отсутствуют двери и окна.
Критическая (Critical) Дефект приводит к невозможности за-
вершить выполнение бизнес-процесса,
но возможно завершить этот процессS3Значительная (Major)
S4Незначительная
(Minor)
S5Неудобство (Tweak)
S6Текст/опечатка (Text)
S7Тривиальная (Trivial)
обходным путем;
Временное отсутствие доступа к неко-
торому функционалу тестируемой си-
стемы;
Существуют точки входа, позволяющие
обойти найденный дефект.
Пример. В доме нет дверей, но можно
войти через окно.
Часть бизнес-логики приложения рабо-
тает с ошибками;
Функционал системы разработан, но ра-
ботает с ошибками;
Ошибки в системе безопасности.
Не организовано взаимодействие между
модулями системы;
Отдельные модули, например сервер,
работают некорректно;
Существует множество точек входа,
позволяющих обойти найденный де-
фект.
Пример. В дом можно войти через под-
вал или по системе вентиляции (множе-
ство точек входа). Дверь открывается,
но в нее не пройти.
Бизнес-логика тестируемого приложе-
ния не нарушена.
Проблемы в удобстве использования
или в дизайне пользовательского ин-
терфейса.
Пример. В доме есть дверь. на двери
написано «От себя», хотя она открыва-
ется на себя.
Нарушены правила usability пользова-
тельского интерфейса.
Пример. До двери в доме приходится
добираться по веревочной лестнице
Небольшая текстовая ошибка/опечатка.
Пунктуационная или орфографическая
ошибка.
Пример. Над входом в дом написано:
«Здрасьте»
Проблема сторонних графических илипрограммных библиотек, а также внеш-
них сервисов.
Не оказывает никакого влияния на об-
щее качество продукта.
Пример. На крыше установлена антен-
на, сигнал от которой не передается
устройствам в доме.
Классификация по скорости исправления дефектов
Вторая классификация — по скорости исправления, приоритету (priority).
Чем выше приоритет, тем быстрее надо исправить дефект. Им часто пользуются,
чтобы правильно передать задачи от тестировщиков — разработчикам. Как пра-
вило, приоритет обнаруженного дефекта определяет руководитель тестировщи-
ков (табл.2).
Таблица 2 - Градация приоритетов
Обозначение
Описание
Высокий (High)
Требуется срочное исправление
Высокий (High)
Исправление важно, но не является срочным
Высокий (High)
Исправление может быть отложено на достаточно дли-
тельный срок
Отчет по дефекту можно создавать в любой среде – табличном редакторе
или Яндекс.Таблицах, в среде систем управления проектами или в специальных
отслеживания ошибок. Важно понимать алгоритм его создания.
1.
Обнаружить дефект.
2.
Понять суть проблемы.
3.
Воспроизвести дефект.
4.
Проверить наличие описания найденного вами дефекта в системе
управления дефектами.
5.
Сформулировать суть проблемы в виде «что сделали, что получили,
что ожидали получить».
6.
Заполнить поля отчёта, начиная с подробного описания.
7.
После заполнения всех полей внимательно перечитать отчёт, испра-
вить неточности и добавить подробности.
8.
Ещё раз перечитать отчёт.
На рис.6 показан пример отчета по дефекту, зафиксированному в баг-
трекинговой системе Mantis. Показана полная структуру отчета: название, шаги
по воспроизведению, приоритет, состояние, влияние на программную систему.Рисунок 6- Фрагмент отчета о дефекте в баг-трекинговой системе Mantis
Второй пример (рис.7) показывает полную структуру отчета с идентифика-
торами, показывающими номер введенной задачи, проектом, для которого
найдены багги, датой создания и что важно – в дополнительных сведениях запи-
сана информация о фактическом результате и ожидаемом.
Рисунок 7 - Отчета о дефекте в баг-трекинговой системе Mantis
Необходимо помнить, что тестировщик только фиксирует проблему, не пы-
тается дать ей оценку, не выявляет причину ее появления и не предлагает пути
решения.
Список источников
1.
Тестирование программного обеспечения. Базовый курс: практ. по-
собие. / С. С. Куликов. — Минск: Четыре четверти, 2015. С. 294.
2.
Орлов С.А. Программная инженерия. Технологии разработки про-
граммного обеспечения: учебник. — СПб: Питер, 2020. С.640.8.2. Баг-трекинговые системы
Баг-трекинговые системы или системы отслеживания ошибок предназначе-
ны для обеспечения совместной работы по нахождению, документированию,
хранению информации о найденном дефекте. Фиксация найденных дефектов в
одной системе позволяет проследить путь решения возникшей проблемы и
найти причину ее возникновения.
Системы отслеживания ошибок (анг. bug tracking systems, далее – BTS) –
прикладные программы, используемые разработчиками программного обеспе-
чения с целью упрощения контроля над этапами разработки проекта и устране-
ния возникающих ошибок
Для поддержки процесса тестирования организация может выбрать BTS,
принимая во внимание следующие критерии: функциональные возможности,
стоимость, расширяемость и наличие хорошо организованного интернет-
сообщества (комьюнити) для помощи в решении сложных задач.
Под функциональными возможностями понимают:
– документирование дефектов с возможностью записи информации о
найденном дефекте, снимках экрана (скриншотах) и др.;
– сопровождение каждого этапа жизненного цикла дефекта специали-
стом по его устранению, в частности программистом, тестировщиком
или менеджером проекта;
– настройку системы в соответствии с внутренним рабочим процессом,
в частности, в зависимости от методологии проектирования инфор-
мационных систем, которая принята в организации-разработчике;
– автоматическое генерирование задач для специалистов, которые при-
нимают участие в устранение программных дефектов на основе по-
ступивших в систему данных;
– администрирование настроек системы, например, цветовое выделение
групповых действий;
– возможность аналитической обработки данных о дефектах;
– оценивание трудозатрат по исправлению найденных ошибок.
Любая баг-трекинговая система поддерживает ролевую модель ведения
проекта, в которой определены специализации участников разработки, в частно-
сти, аналитик, тестировщик или менеджер проекта. При бета-тестировании, а так
же на этапе эксплуатации к системе подключают пользователей, которые буду
самостоятельно фиксировать найденный дефект.Бета-тестирование проводят пользователи программной системы на рабо-
чих местах в программной среде предприятия –заказчика.
Фиксацию найденных ошибок проводят с системах управления проектами,
системах управления тестированием, в системах отслеживания ошибок. Команда
проекта определяет, какую систему использовать. Редмайн, Bugzilla, Mantis или
Jira. Системы отечественного производства представлены платформой Test it и
Яндекс. Трекер (рис.1).
Рисунок 1 - Логотипы BTS
Подробнее рассмотрим облачный сервис для совместной работы и органи-
зации
процессов
в
компании
Yandex
Tracker
(https://cloud.yandex.ru/services/tracker). Все данные в Tracker хранятся на терри-
тории России с учётом законодательных требований. Он спроектирован для ра-
боты с большим объёмом задач. Позволяет автоматизировать рутинные дествия
и сэкономить время с помощью триггеров, автодействий и макросов.
Рисунок 2 - Стартовая страница Yandex Tracker
Система Mantis (https://www.mantisbt.org/) поддерживает ролевую модель
организации процесса тестирования. Каждому зарегистрированному в ней поль-зователю присвоена определенная роль: тестировщик, менеджер проекта, про-
граммист и т.д. Интерфейс пользователя прост и представлен в табличном виде.
Пользователи имеют возможность выбрать язык интерфейса, например, русский
или английский.
Меню системы позволяет выбрать проект, тестирование которого проводят,
посмотреть на все задачи этого проекта, создать новую задачу – отчет о найден-
ном дефекте, посмотреть план закрытия дефектов и журнал деятельности. Также
тестировщикам видны недавно просмотренные ими задачи (рис.3).
Рисунок 3 - Интерфейс BTS Mantis
В списке задач виден номер каждой задачи, степень ее влияния, состояние
выполнения, приоритет. Для понимания сути задачи в списке выведено название
каждой задачи. Поэтому так важно правильно называть баг-репорт. Список
можно экспортировать в текстовом формате в CSV-файл или в Excel (рис.4).
Рисунок 4 - Список задач в Mantis9. ОРГАНИЗАЦИЯ ПРОЦЕССА ТЕСТИРОВАНИЯ
9.1. ОРГАНИЗАЦИЯ ПРОЦЕССА ТЕСТИРОВАНИЯ
Основной целью тестирования является обеспечение качества программного
продукта на том уровне, который заложен в техническом задании. Основопола-
гающим документом для оценки признан ГОСТ ИСО МЭК 9126. «Информацион-
ная технология. Оценка программной продукции. Характеристики качества и ру-
ководства по их применению». Также при тестировании опираются на ГОСТЫ
серии 56922 «Системная и программная инженерия. Тестирование программного
обеспечения» Части 1, 2 и 3 и международные стандарты, например, Стандарт
IEEE 829-1998 Standard for Software Test Documentation.
Международные стандарты и российские госты взаимосвязаны, однако каж-
дому документу присущи свои особенности в определениях артефактов тестиро-
вания. Поэтому мы будем ссылаться на термины, которые определены междуна-
родным советом по сертификации тестирования программного обеспечения
ISTQB и параллельно давать определения из российских гостов. На собеседова-
нии при приеме на работу могут задавать вопросы, называя артефакты тестирова-
ния по-разному, но имея ввиду одни и те же сущности.
В соответствии с определением ISTQB1:
Процесс тестирования (test process): Фундаментальный процесс тестирова-
ния охватывает планирование тестирования, анализ и дизайн тестов, внедрение и
выполнение тестов, оценку достижения критериев выхода и отчетность, а также
работы по завершению тестирования.
В соответствии с ГОСТОм 56920 определение процесса тестирования следу-
ющее:
Процесс тестирования (test process): Обеспечивает информацию о качестве
программного продукта, зачастую состоит из множества действий, сгруппирован-
ных в один или несколько подпроцессов тестирования.
Пример – Процесс тестирования для определенного проекта может состоять
из множества подпроцессов, например, подпроцесса тестирования системы, под-
процесса планирования тестирования (часть большего процесса менеджмента те-
стирования) или подпроцесса статического тестирования.
Глоссарий ISTQB URL: https://glossary.istqb.org/ru_RU/search
1Этапы процесса тестирования
Выделяют основные этапы процесса тестирования (рис.1).
– Планирование (Plan Test).
– Проектирование/разработка тестов (Design Test).
– Реализация тестов (Implement Test).
– Выполнение тестов (Execute Test).
– Оценка и анализ результатов тестирования (Evaluate Test).
– И управления процессом тестирования (Test Management).
Также процесс организации тестирования можно условно разделить на две фазы:
Выполнение и Планирование.
Рисунок 1 – Этапы процесса тестирования
Фаза планирования
Фаза планирования описывает планирование процесса тестирования, осно-
ванное на рисках, определяет метрики оценки тестов, плана тестирования и рас-
пределения работ внутри коллектива тестировщиков.
Риск – это потенциальная потеря (нежелательный результат, но не обяза-
тельно таковой), возникающая в результате какого-либо воздействия или деятель-
ности.
Оценка теста – это приблизительное определение того, сколько времени по-
требуется для выполнения задания. Оценка трудоемкости теста является одной из
основных и важных задач в управлении тестированием.План тестирования – это документ, описывающий объем, подход, ресурсы и
график предполагаемых мероприятий по тестированию.
Организация тестов при тестировании программного обеспечения – это про-
цедура определения ролей в процессе тестирования. Она определяет, кто и за ка-
кие действия отвечает в процессе тестирования.
Фаза выполнения
Фаза выполнения состоит из мониторинга артефактов тестирования, кон-
троля за исполнением сроков реализации и решения возникающих проблем.
Мониторинг – это процесс сбора, регистрации и предоставления информа-
ции о деятельности проекта, которую необходимо знать менеджеру проекта и
стейкхолдерам.
Контроль проекта – это процесс использования данных, полученных в ходе
мониторинга, для приведения фактических показателей к запланированным. Ре-
шение проблем, которые возникают при тестировании.
Отчет с оценкой тестирования описывает результаты тестирования с точки
зрения покрытия теста и критериев выхода. При оценке тестов используются све-
дения, основанные на данных о результатах тестирования и сводной информации
о результате тестирования.
9.1.1. Процесс тестирования и его артефакты
Рассмотрим первые пять этапов процесса тестирования.
1. Планирование.
2. Проектирование/разработка тестов.
3. Реализация тестов.
4. Выполнение тестов.
5. Оценка и анализ результатов тестирования.
Отметим, что процесс тестирования отличается от процесса управления те-
стированием. Они взаимосвязаны между собой и влияют друг на друга.
Рассмотрим процесс тестирования и его артефакты: тестовый план, тест-ди-
зайн, выполнение тестов, оценка результатов тестирования.
Структура плана тестирования
Все работы, связанные с планированием и организацией процесса тестирова-
ния, входят в тестовый план. Это большой многостраничный документ. Он со-
стоит из разделов, в каждом из которых описывают часть процесса тестирования.
В нем определены объекты тестирования, подходы к тестированию и критериипрохождения тестов. Показаны, какие результаты тестированию ожидают, прио-
ритеты задач. Требования к программному окружению, вычислительным мощно-
стям тестовых стендов и кадровому обеспечению. В тестовом плане учитывают
возможные риски и планируют организацию процесса тестирования на основе
рисков и непредвиденных обстоятельств.
Структура плана тестирования
1. Идентификатор тест плана.
2. Ссылки.
3. Введение.
4. Объекты тестирования.
5. Проблемы и риски.
6. Функции, которые нужно протестировать.
7. Функции, которые НЕ нужно тестировать.
8. Подходы.
9. Критерии прохождения тестов для объектов тестирования.
10. Критерии остановки и требования для возобновления.
11. Результаты тестирования.
12. Оставшиеся задачи тестирования.
13. Требования среды.
14. Требования по части кадров и их обучения.
15. Распределение обязанностей.
16. Расписание.
17. Планирование рисков и непредвиденных обстоятельств.
18. Утверждение.
19. Глоссарий.
В тестовом плане показывают особенности тестирования на разных уровнях
тестирования и соответствующий им процесс тестирования.
1. Уровни планирования и их особенности:
– модульное,
– интеграционное,
– системное.
2. Особенности планирования:
– групповое планирование,
– персональное планирование.
3. Организация тестированияОдним их разделов тестового плана является описание стратегии тестирова-
ния и методологии тестирования. Напомню, что методология тестирования свя-
зана с подходами к разработке ПО, принятыми в организации. Сейчас практикуют
два подхода и их комбинации: водопадная и agile.
Стратегия тестирования определяет, что тестируют в первую очередь, чему
уделяют особое внимание и обдумывают возможные пути оптимизации тестиро-
вания (рис.2).
Рисунок 2 – Приоритеты стратегии тестирования
В тестовом плане проводят приблизительную оценку затрат на тестирование,
основываясь на оценке затрат для решения каждой задачи, включая оценку тре-
буемых ресурсов. Ресурсами могут быть кадровые ресурсы, ресурсы вычисли-
тельной техники, затраты на реализацию тестовой среды. На этом этапе состав-
ляют график работ, например, разрабатывают диаграмму Ганта.
Определяют возможные риски тестирования, планы их предупреждения,
вводят метрики по определению точности рисков.
Оценка рисков
1. Определение основных рисков.
2. Определение планов предупреждения рисков и снижения их влияния.
3. Неопределённые риски.
4. Точность определения рисков.При планировании всегда возникает много проблем. К ним относят непол-
ноту требований, изменяющиеся требования, ошибки в оценке объема работ,
недооценка затрат на процессы интеграции, отсутствие предварительно собран-
ных метрик, кадровые проблемы (рис.3).
Рисунок 3 – Основные проблемы планирования
Организация базы знаний проекта
Желательно в тестовом плане определить, как будет организована база зна-
ний проекта (рис.4). В настоящее время используют программные инструменты
на wiki-движке. В этой базе будет сохранена вся важная информация о проекте,
метрики, тест-кейсы и чек-листы.
Рисунок 4 – Разделы базы знаний проектаКритерии начала и завершения тестирования
Тестовый план определяет критерии начала и завершения тестирования для
каждого теста и проекта в целом (рис.5).
Рисунок 5 – Критерии начала и окончания тестирования
Кейс. Критерии при системном тестировании
Критерии входа определены таким образом:
– Модульное и интеграционное тестирование всех модулей закончено.
– Окружение для системного тестирования готово.
– Спецификации продукта закончены и утверждены.
– Сценарии системного тестирования отражены в документах.
– Пользовательский интерфейс и тестируемый функционал зафиксиро-
ван и в него не вносят изменения.
Критерии выхода:
– Программа отвечает всем требованиям и обладает требуемым функци-
оналом.
– Дефекты, обнаруженные во время системного тестирования, исправ-
лены и закрыты.
– Все сценарии системного тестирования исполнены, а результаты до-
ступны.9.1.2. Проектирование тестов
Тест дизайн (design test) показывает, как можно определить и описать тесто-
вые случаи, тестовые процедуры, измерить тестовое покрытие. Это идеи – за-
думки для тестирования, какие техники и методы тест-дизайна можно применить
при тестировании конкретной задачи. Например, как измерить размер оператив-
ной памяти, требуемой для успешного функционирования программного про-
дукта.
Элементы тест-дизайна.
1. Определение и описание тестовых случаев:
– составление тестов на основе требований,
– оценка рисков требований, ранжирование тестов
2. Определение и структурирование тестовых процедур
3. Обзор и оценка тестового покрытия
– определение методик
– определение метрик
4. Изменение требований в процессе разработки
9.1.3. Реализация тестов
При реализации тестов разрабатывают тестовые наборы данных, опреде-
ляют, какую функциональность можно проверить тестами, обдумывают, как про-
водить тесты: вручную или автоматизировано (рис.6).
Рисунок 6 – Варианты реализации тестов9.1.4. Выполнение тестов
При выполнении тестов рассматривают варианты успешной реализации те-
стовых процедур, неожиданных результатов, регистрацию дефектов (рис.7).
Рисунок 7 – Действия на этапе выполнения тестов
1.
2.
3.
4.
5.
Список источников
ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. Системная и программная
инженерия. Тестирование программного обеспечения. Часть 1. Понятия и
определения
Глоссарий ISTQB URL:https://glossary.istqb.org/
Тестирование программного обеспечения. Базовый курс: практ. пособие. / С.
С. Куликов. — Минск: Четыре четверти, 2015. С. 294.
Орлов С.А. Программная инженерия. Технологии разработки программного
обеспечения: учебник. — СПб: Питер, 2020. С.640.
Справочник QA-инженера. URL https://sergeygavaga.gitbooks.io/9. ОРГАНИЗАЦИЯ ПРОЦЕССА ТЕСТИРОВАНИЯ
9.2. УПРАВЛЕНИЕ ПРОЦЕССОМ ТЕСТИРОВАНИЯ
Управление процессом тестирования относят к задачам менеджмента. Рас-
смотрим подходы к определению управления процессом тестирования.
Определение по ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013. «Систем-
ная и программная инженерия. Тестирование программного обеспечения.
Часть 1. Понятия и определения».
Управление тестированием – это процесс управления тестовой деятельно-
стью с целью обеспечения высококачественного и высококлассного тестирования
программного приложения.
Он заключается в организации, контроле, обеспечении отслеживания и види-
мости процесса тестирования с целью создания высококачественного программ-
ного приложения. Это обеспечивает выполнение процесса тестирования про-
граммного обеспечения в соответствии с ожиданиями.
В глоссарии ISTQB есть два определения.
Управление тестированием: Процесс планирования, составления плана-
графика тестов активностей, оценки, мониторинга, отчетности, контроля и завер-
шения тестовых мероприятий.
Менеджмент тестирования (test management): Планирование, составление
графика, оценка, мониторинг, отчетность, управление и выполнение действий по
тестированию.
При управлении тестированием рассматривают часть задач, которые входят
в процесс тестирования и определены затем в тестовом плане:
1. Определение задач тестирования и требований к процессу тестирования.
2. Оценка рисков.
3. Определение метрик процесса.
4. Выбор технологии и инструментов тестирования.
5. Определение объёма и структуры документации.
6. Определение требуемых для проведения тестов ресурсов.
7. Распределение ролей и ответственности.
8. Разработка «Плана тестирования».
Круг заинтересованных лиц
Управление тестированием относят к менеджменту, поэтому определяют
круг заинтересованных лиц в тестировании.1. Разработчики, руководители группы разработки, менеджеры проекта.
2. Архитекторы баз данных и системные архитекторы.
3. Тестировщики, непосредственно отвечающие за тестирование продукта.
4. Маркетологи, бизнес-аналитики.
5. Менеджеры проекта.
6. Высший менеджмент, менеджеры продукта, спонсоры проекта.
7. Служба поддержки.
8. Менеджеры по продажам, инженеры.
9. Государственные структуры.
10. Пользователи.
Определяют сроки тестирования, основываясь на знании продукта, количе-
стве сессий тестирования, типе тестирования, компетентности команды, исправ-
ление дефектов (табл.1).
Таблица 1 – Пример расчета на трудоемкости задач
Задача
Время, ч
Тестирование процесса установки продукта20
Тестирование графического интерфейса35
Тестирование сетевых подключений12
Тестирование базы данных23
Составление отчета10
Итого100
Управление процессом тестирования основано принципе Деминга «Плани-
руй, делай, проверяй, действуй» (рис.1). Его цель – постоянное совершенствова-
ние процессов организации с течением времени.Рисунок 1 – Принцип оценки зрелости Деминга
Поэтому тест-менеджер выбирает модель оценки зрелости для организации
процесса тестирования, в соответствии с которой будут выстраивать взаимодей-
ствие в команде и проводить организационные мероприятия внутри компании.
Модели по оценке зрелости отличают
– Шкалы (уровни) зрелости.
– Процессные модели и способы их применения.
На рис.2 показаны 4 модели для оценки зрелости. Компании по разработке
ПО могут выбрать любую из них.
Рисунок 2 – Модели по оценке зрелостиПоказатели качества
Показателями качества могут быть метрики для процесса тестирования и
KPI – для управления процессом тестирования.
Метрика – технически или процедурно измеримая величина, характеризую-
щая состояние объекта управления.
KPI (key performance indicators) – это числовые показатели деятельности, ин-
дикаторы состояния объекта управления, которые помогают измерить степень до-
стижения целей или оптимальности процесса, а именно: результативность и эф-
фективность. Обязательное условие – наличие целевого значения и установлен-
ные допустимые отклонения.
Рассмотрим метрики тестирования, которые определяют процесс тестирова-
ния и на основе которых впоследствии рассчитывают KPI, вводя дополнительные
весовые коэффициенты для каждой метрики.
Метрики бывают прямые и расчетные.
К прямым метрикам относят:
– количество разработанных тест-кейсов;
– количество найденных дефектов;
– время прохождения тест-кейсов и так далее.
Расчётные метрики вычисляют по формулам. Они показывают:
– процентное отношение выполненных/невыполненных тест-кейсов
ко всем имеющимся;
– процент успешного прохождения тест-кейсов (ко всему объёму тест-
кейсов);
– процент заблокированных тест-кейсов (ко всему объёму тест-кейсов)
– плотность распределения дефектов;
– эффективность устранения дефектов;
– распределение дефектов по важности и срочности.
Чтобы рассчитать метрики, проводят сбор показателей.
Количество ошибок – общее количество или же их распределение по прио-
ритетам.
Качество ошибок – насколько понятно и эффективно тестировщики оформ-
ляют баг-репорты.
Тестовое покрытие требований, кода, пользовательских сценариев, окруже-
ний, покрытие за цикл тестирования и на одной сборке.Скорость тестирования одной сборки, полного тестового цикла, скорость
внесения критических ошибок программного продукта в баг-трекинговую си-
стему
Эффективность планирования – насколько велики расхождения между
предполагаемым и реальным сроками завершения работ.
Тестовое покрытие
При тестировании ПО часто встречают метрики, основанные на тестовом по-
крытии. Тестовое покрытие – это одна из метрик оценки качества тестирования,
представляющая из себя плотность покрытия тестами требований либо исполня-
емого кода.
Сложность современного ПО и инфраструктуры сделало невыполнимой за-
дачу проведения тестирования со 100% тестовым покрытием.
Оценку тестового покрытия проводят на основе метрик покрытия требовани-
ями, покрытия кодом и тестового покрытия на базе анализа управления.
Покрытие требований – это оценка покрытия тестами функциональных и
нефункциональных требований к продукту путем построения матриц трасси-
ровки.
Покрытие кода – это оценка покрытия исполняемого кода тестами путем
отслеживания непроверенных в процессе тестирования частей ПО.
Тестовое покрытие на базе анализа потока управления это одна из техник
тестирования белого ящика, основанная на определении путей выполнения кода
программного модуля и создания выполняемых тест кейсов для покрытия этих
путей
Критерии завершения тестирования
Важно определить критерии завершения процесса тестирования. Они, как
правило, записаны в тестовом плане. Но могут быть изменены в процессе выпол-
нения тестирования из-за вновь открывшихся обстоятельств.
Выходные критерии – это совокупность условий, которые должны быть вы-
полнены, чтобы фаза тестирования была успешно закрыта.
Примеры выходных критериев:
– Достигнут дедлайн (релиза, тестирования).
– Достигнут необходимый процент успешно пройденных тест-кейсов.
– Покрытие кода/функционала/требований достигло требуемого уровня.
– Все дефекты исправлены или закрыты.– Все тест-кейсы выполнены.
– Завершен бета- или альфа-период тестирования.
– Бюджет, выделенный на тестирование, исчерпан.
Организация документооборота
Любое управление невозможно без документации. Поэтому перечислим ос-
новные документы.
1. Тестовые требования (Test Requirements).
2. Тестовые планы (Test Plan).
3. Тесты (Test Case).
4. Отчёты о прохождении тестов (Test Report).
5. Отчёты о проблемах (Bugg Report).
6. Отчёт по тестированию (Summary Test Report).
Завершают тестирование проверки по обеспечению качества, передача арте-
фактов тестирования заинтересованным лицам, документирование полученного
опыта тестирования, архивирование документов.
Системы управления проектами
Управление процессом тестирования проходит с помощью систем управле-
ния проектами. Управление тестированием относят к задачам управления проек-
том. Поэтому для организации процесса тестирования используют системы
управления проектами.
Система управления проектами – это набор организационных и технологи-
ческих методов и инструментов, которые поддерживают управление проектами в
компании и помогают повысить эффективность их реализации.
К таким система относят Jira, Яндекс.Трекер, Битрикс24, Мегаплан. Каждая
из систем показывает ход и процесс работы над программным продуктом, трудо-
затраты на решение каждой задачи, загрузку каждого сотрудника.
Подробнее рассмотрим облачную систему Kaiten, в основе которой лежит
принцип kanban-визуализации. Для каждого проекта предусмотрено простран-
ство – область, в которой можно располагать одновременно несколько Kanban-
досок. На каждой доске расположены карточки с задачами, которые необходимо
выполнить в ходе реализации проекта (рис.3).Рисунок 3 – Доска проекта в Kaiten
Функционал Кайтен позволяет автоматически создавать отчеты по тестиро-
ванию и визуализировать результаты: например, в формате таймлайнов (рис.4-5).
Рисунок 4 – Отчет о процессе управления тестированием
Рисунок 5 – Диаграмма выполнения задач проекта9. ОРГАНИЗАЦИЯ ПРОЦЕССА ТЕСТИРОВАНИЯ
9.3. ОРГАНИЗАЦИЯ СРЕДЫ ТЕСТИРОВАНИЯ
В системах управления тестированием фиксируют тест-кейсы и документы
по тестированию, в баг-трекинговые системы заносят отчеты о найденных инци-
дентах, сопровождая их скриншотами и комментариями. Также тестировщику по-
требуются программы для документации в текстовом или табличном виде, про-
граммы для записи видео и создания скриншотов. Специалист по тестированию
должен знать множество специализированных инструментов для проведения те-
стирования и выбирать конкретный для решения поставленной задачи.
В глоссарии ГОСТа ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013 «Си-
стемная и программная инженерия. Тестирование программного обеспечения.
Часть 1. Понятия и определения», который создан на основе международных
стандартов, дано следующее определение:
Процесс Выполнения Тестирования (Test Completion Process): Процесс
менеджмента тестирования, необходимый для обеспечения доступности полез-
ных активов тестирования для дальнейшего использования, обеспечения удовле-
творительного состояния тестовых сред, гарантии документирования и передачи
соответствующим заинтересованным сторонам результатов тестирования.
Команда тестировщиков отвечает за качество реализованного программного
продукта. Для тестирования которого потребуются навыки работы в различных
программных средах, начиная от простой фиксации скриншота экрана монитора
и заканчивая, например, автоматизированным тестированием производительно-
сти и/или тестированием безопасности.
Компоненты среды реализации и тестирования:
1. Среда для создания программного кода.
2. Среда хранения версий программного кода и документации к проекту.
3. Среда создания тестовых наборов.
4. Тестовая среда для проведения проверок.
5. Система хранения тест-кейсов.
6. Баг-трекинговая система.
7. Система управления проектом.
8. Программные инструменты для логирования.
9. Программные инструменты для сбора тестовых доказательств и многие
другие.Тестовая среда
В процессе тестирование разворачивают тестовую среду. Она включает ап-
паратное обеспечение, измерительную аппаратуру, имитаторы, программный ин-
струментарий и прочие инструменты, необходимые для проведения теста.
Тестовая среда (Test Env) – различные средства, аппаратное и программное
обеспечение, встроенное микропрограммное обеспечение, процедуры и докумен-
тация, предназначенные или используемые для выполнения тестирования про-
граммного обеспечения.
Тестирование в условиях, приближенным к реальным, проводят на испыта-
тельном стенде. На нем проведены настройки тестовой среды для проведения
конкретных видов тестирования на подготовленных данных.
Испытательный стенд (Test Bed) – включает оборудование, операционную
систему, конфигурацию сети, тестовые данные, которые полностью настроены
для проведения тестирования ПО.
Программно-аппаратное окружение процесса тестирования
Рассмотрим типы программного окружения процесса тестирования:
‒ В среде разработки программисты пишут код, проводят отладку, исправ-
ляют ошибки, выполняют Unit-тестирование. За эту среду отвечают также разра-
ботчики.
‒ В среде тестирования проверяют новые сборки программного продукта:
функционал, проводят регрессионные проверки. На этом этапе начинается дина-
мическое тестирование, т.е. с запуском приложения на исполнение, тестирование.
‒ Интеграционная среда иногда реализована в рамках среды тестирования, а
иногда в рамках превью среды. В этой среде собрана необходимая для end-to-end
тестирования схема взаимодействующих друг с другом модулей, систем, продук-
тов.
‒ Preview среда, максимально приближенная к реальной (боевой): те же дан-
ные, то же аппаратно-программное окружение, та же производительность. Здесь
тестировщики проводят заключительное end-to-end тестирование функционала.
‒ В среде production работают пользователи и специалисты поддержки.
Следует отметить, что в курсе рассмотрены бесплатные программные ин-
струменты, которые внесены в реестр отечественного программного обеспечения
или имеют открытый программный код (https://catalog.arppsoft.ru/section/2117).Системы управления проектом
Управление тестированием относят к задачам управления проектом. По-
этому для организации процесса тестирования используют системы управления
проектом.
Система управления проектами – это набор организационных и технологи-
ческих методов и инструментов, которые поддерживают управление проектами в
компании и помогают повысить эффективность их реализации.
Программные инструменты тестирования клиентской и серверной частей
Как правило, архитектура современного приложения построена с использо-
ванием шаблона MVC (Model-View-Controller) (рис.1). Поэтому можно базу дан-
ных можно протестировать параллельно интерфейсу приложения. Также многие
веб-приложения построены на архитектурном паттерне «клиент-сервер», кото-
рый также позволяет отдельно проводить тестовые мероприятия для клиентской
и серверной стороны.
Рисунок 1 – Шаблон MVC
При тестировании клиентской части необходимо знать специальные ин-
струменты, которые позволяю проверить верстку макета, соответствие дизайн-
макету, функциональность каждого элемента, реализовать автоматизацию тесто-
вых проверок. При тестировании фронтенда проводят ручное и автоматизирован-
ное тестирование.Инструменты тестирования:
1. Selenium. Автоматизации действий веб-браузера (https://www.selenium.dev)
2. Браузерное расширение PerfectPixel. Проверка соответствия макету
разработанной
web-страницы
(https://chrome.google.com/webstore/detail/
perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi)
3. Тестирование верстки с помощью валидатора W3C (https://validator.w3.org/)
Для проверки доступа к серверной части и ее функционирования приме-
няют программные инструменты Postman, Katalon, JMeter. Как правило, на сер-
верной части и при тестировании API проводят автоматизированное тесты (рис.2).
Рисунок 2 – Программные инструменты для тестирования серверной части
Непрерывная интеграция
Актуальным подходом к разработке программного обеспечения является не-
прерывная интеграция. Она позволяет выполнять отправку, сборку и тестирова-
ние нового кода по мере его написания (рис.3).
Рисунок 3 – Непрерывная интеграцияИдея интеграции состоит в следующем. Файлы проекта хранят в репозито-
рии, к которому имеют доступ вся команда проекта (рис.4). Как только разработ-
чик напишет новый модуль или сделает рефакторинг, он сразу передает его в ре-
позиторий и добавляет в проект. Чтобы проверить работоспособность проекта по-
сле внесения изменений, запускаются автотетсы на проверку интеграции и про-
водят регрессионное тестирование.
Рисунок 4 – Идея интеграции
При тестировании используют специальные программные инструменты, та-
кие как Jenkins. Также в обеспечении непрерывной интеграции участвуют си-
стемы контроля версий – репозитории, например Git, в которых сохраняют файлы
проекта и ветви проекта. Для облачного хранения данных проекта используют
специальные платформы для хостинга и совместной работы, например Github или
Gitlab.
Рисунок 5 – Сервисы по обеспечению непрерывной интеграцииПрограммные среды для разработки ПО
При проверке работоспособности программного продукта, тестировщики
могут иметь доступ к программному коду. В этом случае тестирование проводят
методом «Белого ящика».
Тестировщику необходимо открыть скрипт в принятой на проекте среде IDE,
например Visual Studio Code.
IDE (Integrated Development Environment) и редактор кода – это виды
программного обеспечения, предназначенные для работы над приложениями, их
разработки и тестирования.
Состав IDE:
– текстовый редактор для написания и редактирования кода;
– компилятор – инструмент, позволяющий перевести текст, написанный на
языке программирования, в набор машинных кодов;
– отладчик, проверяющий код и устраняющий в нем ошибки;
– инструментов для автоматизации сборки кода, ускоряющих процесс раз-
работки.
Выбор IDE зависит от задач проекта, поэтому тестировщику полезно ознако-
миться с возможностями Visual Studio Code, РyCharm, Notepad++, Sublima Text,
Netbtans (рис.6).
Рисунок 6 – Примеры программных сред и IDE
Системы управления тестированием
Все тест-кейсы, артефакты тестирования, сопроводительная документация
могут быть сохранены в системе управлением тестированием.
Системы управления тестированием (Test Management System, TMS) исполь-
зуются для хранения информации о том, как должным образом проводить тести-
рование, осуществление очередности проведения тестирования в соответствии с
его планом, а также для получения информации в виде отчетов о стадии тестиро-
вания и качестве тестируемого продукта.К базовым задачам таких систем относят.
1. Создание и управление проектами.
2. Создание пользователей и проектных ролей для пользователей.
3. Удобная интеграция с автоматическими тестами.
4. Работа с тестовыми артефактами: тест-план, тест-кейс, чек-лист, общие шаги.
5. Версионирование тест-кейса/чек-листа.
6. Создание пользовательских атрибутов/конфигураций.
7. Понятная система отчётности.
8. Встроенная система баг-трекинга.
9. Возможность оповещения коллег внутри и вне системы.
10. Возможность интеграции с другими инструментами.
Примером отечественной сиcтемы управления тестированием служит Test It
(https://testit.software/product). Также на проектах могут использовать облачную
систему Qase (https://qase.io/).
Баг-трекинговые системы
Вместе с системами управления тестированием и системами управления
проектами применяют баг-трекинговые системы.
Системы отслеживания ошибок (анг. bug tracking systems, далее – BTS) – при-
кладные программы, используемые разработчиками программного обеспечения с
целью упрощения контроля над этапами разработки проекта и устранения возни-
кающих ошибок
К таким системам относят многофункциональную платформу Test It,
Яндекс.Трекер, Mantis.
Генераторы тестовых данные
При создании тестовый среды и тестового стенда необходимо использовать
наборы тестовых данных.
‒ Реальные тестовые данные: требуются для проверки функциональности
программной системы;
‒ Тестирование на вымышленных тестовых данных покажет, как отреаги-
рует система на ввод фактически неправильных значений, будет ли выведено со-
общение для пользователя о том, что таких данных не может быть.
‒ Пограничные значения выявят проблемы, которые часто встречаются
именно на границах классов эквивалентности;‒ Тестировщику следует проверить, как реагирует система на ввод информа-
ции в неправильном формате, есть ли данные об ошибках;
‒ Также важно протестировать продукт на использование полей без ввода
каких-либо значений.
Наборы тестовых данных важны при тестировании бизнес-логики или базы
данных. Для их создания используют генераторы, например, сервис datprof.com.
Они позволяют анонимизировать реальные данные или сгенерировать с нуля син-
тетические (с характеристиками настоящих данных).
Вспомогательные программные инструменты
При документировании дефекта необходимо предоставлять информацию о
том, где найден дефект и в чем он себя проявляет. Бывает так, что словами описать
увиденное сложно. Поэтому тестировщики делают скриншот экрана или записы-
вают видео. Примером такого полезного инструмента является FastStone.
Процесс реализации программного продукта сопровождает документация.
Ее можно создавать в любом редакторе, который принят в организации, с помо-
щью Markdown или Word, Latex или Notepad++ (рис.7).
Рисунок 7 – Программные инструменты для создания документации
В своей работе тестировщику необходимо взаимодействовать с разными про-
граммными средами, поэтому к важным в этой профессии навыкам относят уме-
ние быстрой адаптации и знакомства с теми программными средами, которые
приняты на проекте.9. ОРГАНИЗАЦИЯ ПРОЦЕССА ТЕСТИРОВАНИЯ
9.4. РЕПОЗИТОРИЙ ПРОЕКТА
При работе над программным проектом каждый из команды разработчиков
должен иметь доступ ко всем файлам. Поэтому возникает необходимость органи-
зации виртуального хранилища программных компонент в системе контроля вер-
сий.
Система управления версиями позволяет хранить несколько версий одного и
того же документа, при необходимости возвращаться к более ранним версиям,
определять, кто и когда сделал то или иное изменение.
Подходы к сохранению изменений в файлах проекта
При сохранении изменений файлов проекта существует два подхода.
Первый подход – сделать снимок или слепок файла (snapshot). После моди-
фикации файла сделать новый слепок и сохранить оба снимка. При необходимо-
сти можно вернуться к ранее сохраненным снимкам. При таком подходе требу-
ется много места для одновременного хранения нескольких версий файлов
Второй подход предусматривает сохранения разницы – дельты изменений
между новой версией и старой версией файла и сохраняет только эту разницу.
На основе этих двух подходов разработано большое количество систем
управления версиями. Работы с системами контроля версий рассмотрим на при-
мере распределенной системы управления версиями Git.
Система управления версиями Git
Git – специальная программа, позволяющая контролировать изменения фай-
лов проекта как для одиночной, так и совместной разработки кода.
Систему Git создал в 2005 году Линус Торвальдс, когда вместе с командой
разрабатывал ядро операционной системы Linux.
К ее задачам относят:
1. Возврат к любой версии кода
2. Просмотр истории изменений и восстановление любых данных
3. Совместная работа разработчиков
Программные средства данной системы позволяют сохранить изменения в
файл или набор файлов в процессе их модификации и при необходимости вер-
нуться к конкретной версии файла. Если над проектом работают несколько чело-
век, то каждому из них обеспечивают доступ для совместной работы над файлом.Каждое внесенное изменение фиксируют, поэтому возникает многоверсионность
разрабатываемого программного продукта.
Базовые определения
Познакомимся с базовыми определениями:
• repository – некоторое хранилище файлов, ссылок на изменения в файлах
• commit – отслеживание изменений, сохраняет разницу в изменениях
• working directory – рабочий каталог на вашем компьютере
• staging area, index – область подготовленных файлов или рабочая область
• branch – ветка, состоит из набора коммитов, обычно ссылается на послед-
ний коммит
• merge – слияние, слияние веток в одну
• pull – взять проект с сервера, получить изменения из удаленного репозито-
рия
• push – отправить изменения на сервер
Git считает хранимые данные набором слепков небольшой файловой си-
стемы. Каждый раз при фиксации текущей версии проекта, Git, по сути, сохраняет
слепок того, как выглядят все файлы проекта на текущий момент (рис.1). Если
файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранён-
ный файл.
Рисунок 1 – Подход к хранению файлов и изменения в Git
В репозитории хранят все файлы проекта. Для того, чтобы начать с ними ра-
ботать, их необходимо скопировать в рабочий каталог. С точки зрения Git каждый
файл может находится только в одном из двух состояний: отслеживаемый и неот-
слеживаемый (рис.2).Рисунок 2 – Состояния файлов Git
1. Отслеживаемый. Об этих файлах Git знает и отслеживает изменения в них.
Отслеживаемые файлы в свою очередь могут находится в следующих состояниях:
‒ Неизмененный (unmodified). То есть с момента последнего коммита в
файле не было никаких изменений.
‒ Измененный (modyfield). То есть с последнего коммита в файле были про-
изведены какие-то изменения.
‒ Подготовленный к коммиту (stage). Это значит, что вы внесли изменения в
этот файл и затем проиндексировали их, и эти изменения будут добавлены в сле-
дующий коммит.
2. Неотслеживаемый (untracked). О неотслеживаемых файлах Git не знает,
поэтому изменения в них не будут добавлены в коммит. Это любые файлы в ва-
шем рабочем каталоге, которые не входили в последний коммит и не подготов-
лены к текущему коммиту.
В репозитории хранят все файлы проекта. Для того, чтобы начать сними ра-
ботать их необходимо скопировать в рабочий каталог. После внесенных измене-
ний файлы перемещают в область подготовленных файлов. И только затем пере-
мещают в репозиторий Git, делают коммит.
Репозиторий Git условно можно разделить на три составляющие (рис.3)Рисунок 3 – Перемещение файлов проекта
Рабочая директория – Working directory. Это файловая структура, с которой
непосредственно работает пользователь в конкретный момент времени. Техниче-
ски же – это копия определенной версии вашего проекта, которую вы извлекли из
базы Git и в которую пытаетесь внести свои изменения.
Индекс или Область подготовленных файлов – Index / Staging area. Это об-
ласть, где хранятся имена файлов и изменения в них, которые должны войти в
следующий коммит. Технически индекс – это просто файл.
Директория Git – Git Directory. Папка, в которой Git хранит все версии ва-
шего проекта и также свои служебные файлы. Данная папка носит название .git и
располагается в корневой директории вашего проекта.
При работе над проектом создают ветви (рис.4). Главная ветвь проекта назы-
вают main или master. Другие ветви проекта могут называть deveop, Future или
придумывают любые псевдонимы.Рисунок 4 – Ветви проекта
При фиксации изменений внутри одной ветви проводят коммит, выполнив
команду git commit. Коммитить можно один файл или сразу несколько. Система
сама найдёт, что изменилось в каждом файле, и добавит эти изменения в проект.
Но все эти правки внесутся в репозиторий за один раз, потому что при коммите
обрабатываются сразу все добавленные в список файлы.
Единственное требование к коммитам – указывать, что именно вы поменяли
в проекте, человеческим языком. Хорошим тоном и правильным подходом счита-
ется писать, что именно вы изменили: «Добавил цвет и стили основной кнопки»,
«Убрали метод вызова старого API». Это описание будут читать другие разработ-
чики. Есть правило о коммитах (https://www.conventionalcommits.org/ru/v1.0.0-
beta.2/).
Семь правил хорошего описания коммита:
Правило 1: оставляйте пустую строку между заголовком и описанием.
Правило 2: ограничивайте длину заголовка 50 символами.
Правило 3: пишите заголовок с прописной (заглавной) буквы.
Правило 4: не ставьте точку в конце заголовка описания.
Правило 5: используйте повелительное наклонение в заголовке.
Правило 6: ограничивайте длину строки в теле описания 72 символами.
Правило 7: в теле описания отвечайте на вопросы «что?» и «почему?», а не
«как?».
Новые версии могут разрабатывать в разных ветвях. Для их создания выпол-
няют команду git branch. После выполнения своей части работ разработчику необ-
ходимо объединить свою ветвь с главной. Для добавления нового кода, новых
файлов проекта в репозиторий используют команду git merge.При работе с системой контроля версий следует помнить, что все изменения
происходят в рабочей зоне на компьютере у пользователя. Потом сделанные из-
менения необходимо зафиксировать.
Разработчик сначала забирает файлы проекта к себе командой push request, а
затем передает их обратно на сервер командой pull request. Т.е. делает запрос на
слияние. Если команда его одобряет, то выполняется слияние ветвей.
Рассмотрим некоторые команды без атрибутов и ключей:
• git init – создает новый репозиторий;
• git status – отображает список измененных, добавленных и удаленных файлов;
• git add – добавляет указанные файлы в индекс;
• git commit – фиксирует добавленные в индекс изменения;
• git branch – создать ветку с помощью команды;
• git checkout – создать ветки и сразу переключиться на них;
• git branch – просмотр всех веток.
Подробно с командами гит можно ознакомиться в большой книге ProGit
(https://git-scm.com/book/ru).
Например, в ней будет такое описание команды git add (добавить):
Команда git add добавляет содержимое рабочего каталога в индекс (staging
area) для последующего коммита. По умолчанию git commit использует лишь этот
индекс, так что вы можете использовать git add для сборки слепка вашего следу-
ющего коммита.
Все команды выполняются в консоли. Git – это инструмент для командной
строки, у него нет графического интерфейса. Но у него довольно много приложе-
ний (рис.5) с графическим интерфейсом, например GitHub, GitLab (https://git-
scm.com/downloads/guis/).
Рисунок 5 – Информация о графических клиентах GitОнлайн-сервис GitHub
GitHub – это онлайн-сервис, который основан на технологии Git.
Назначение GitHub:
‒ сохранять репозитории в интернете,
‒ автоматически синхронизировать их с репозиториями у разработчиков,
‒ следить за обновлениями кода,
‒ редактировать код прямо в репозитории,
‒ копировать себе чужие репозитории.
В нем встроены трекер задач, система уведомлений, форум, переписка между
пользователями и комментарии.
GitHub обладает интуитивно понятным, дружелюбным интерфейсом (рис.6).
Начало работы с GitHub:
1. Зарегистрироваться на GitHub;
2. Создать свой репозиторий;
3. Загрузить код на GitHub;
4. Добавить описание репозитория и файл README.md (можно позже).
Рисунок 6 – Интерфейс репозитория на GitHub
Пользователь определяет порядок действий, а GitHub генерирует программ-
ный код команд и выполняет их (рис.7).Рисунок 7 – Автогенерация кода команд
Например, так будут выглядеть изменения, внесенные в программный код
после слияния (рис.8).
Рисунок 8 – Визуализация изменения в коде
Работа в системе контроля версий дает возможность сохранять промежуточ-
ные варианты проекта, авторов и время изменения. В случае неудачного варианта
изменений всегда можно откатиться назад и остановиться на стабильном ком-
мите.
В профиле на GitHub можно разместить контакты, список навыков, код про-
ектов и ссылки на важные ресурсы. Если нет своего сайта, страница сможет его
заменить.10. ПРИМЕНЕНИЕ ИСКУССТВЕННОГО ИНТЕЛЛЕКТА
В ТЕСТИРОВАНИИ
10.1. Подходы к тестированию на основе ИИ
Тестирование на основе искусственного интеллекта (ИИ) – это метод тести-
рования ПО, в котором алгоритмы искусственного интеллекта и машинного обу-
чения используются для эффективного тестирования программного продукта.
Рассмотрим следующие ключевые подходы к тестированию на основе ИИ:
дифференциальное (Differential testing), визуальное (Visual testing), декларативное
тестирование (Declarative testing) и тестирование Self-healing automation с автома-
тическим самовосстановлением [1].
Дифференциальное тестирование
С помощью дифференциального тестирования классифицируют ошибки
приложения и на основе полученных результатов прогнозируют локализацию де-
фектов новой сборки.
Примером инструмента тестирования является Launchable [2]. Используемая
здесь технология Predictive Test Selection базируется на алгоритме машинного
обучения, который прогнозирует вероятность сбоя для каждого теста на основе
анализа предыдущих итераций тестирования ПО.
В первую очередь будут выполнять тесты, которые проверяют те области
локализации дефектов, в которых их вероятность появления выше. Исследования
[3] показали, что выполнение всего 20% тестов, выбранных ИИ, обеспечивает тот
же высокий уровень уверенности в результатах тестирования (90%), что и выпол-
нение взятых случайным образом 75% тестов, сформированных «традиционным»
способом. Такой подход позволяет значительно сократить время выполнения те-
стов.
Визуальное тестирование
Визуальное тестирование (Visual AI) проверяет внешний вид приложения на
основе обученной модели, которая проводит сравнения макета и реализованного
пользовательского интерфейса. Данный вид тестирования имеет особое значение
из-за одновременного существования различных платформ, отличающихся кон-
фигурацией, размером и разрешением экрана, и, следовательно, особенностями
визуализации интерфейса. Среди современных инструментов визуального тести-
рования на основе Visual AI можно выделить Applitools (https://applitools.com/).Платформа Applitools интегрируется со всеми современными средами тестирова-
ния и работает со многими существующими инструментами тестирования, та-
кими как Selenium, Appium, Cypress и т. д.
Декларативное тестирование
Декларативное тестирование направлено на определение цели теста на есте-
ственном или специфическом для конкретной предметной области языке. Си-
стема сама решает, как выполнить тест. Декларативные инструменты тестирова-
ния связаны с автоматизацией роботизированных процессов (Robotic process
automation, RPA), обработкой естественного языка (Natural Language Processing,
NLP), автоматизацией тестирования на основе моделей (Model Based Testing,
MBT) и автономными методами тестирования (Autonomous Testing Methods, AT).
Основная цель этих методов – устранить утомительные, подверженные ошибкам,
повторяющиеся задачи с помощью интеллектуальной автоматизации.
Примером инструмента служит Tricentis (https://www.tricentis.com/). Этот ин-
струмент позволяет командам Agile и DevOps быстро достигать целей автомати-
зации тестирования. Он сочетает в себе разработку тестовых сценариев, автома-
тизацию тестирования, проектирование и генерацию тестовых данных.
Тестирование с автоматическим самовосстановлением
Большинство инструментов на базе искусственного интеллекта обладают
способностью к самотестированию и самовосстановлению. Главной идеей авто-
матического самовосстановления является то, что при изменении свойств эле-
мента автоматически изменяются сценарии тестирования. Например, при измене-
нии параметров кнопки на странице веб-приложения будут автоматически вне-
сены изменения во все тесты, в которых участвует данный элемент. На основании
такого подхода проводят тестирование графического интерфейса, тестирование
производительности, тестирование API. В качестве примера инструментов, ис-
пользующих данный подход, можно привести Mabl (https://www.mabl.com/) и
Testim (https://www.testim.io/). Так, Testim включает в себя самостоятельное об-
служивание автоматических тестов, основанных на машинном обучении.
Преимущества использования ИИ при тестировании
К преимуществам использования методов машинного обучения и ИИ при те-
стировании относят следующие:
1. Поддержка практик непрерывной интеграции и непрерывной поставки.2. Значительное сокращение времени тестирования и ускорение выхода про-
граммного продукта на рынок (снижение показателя Time to Market).
3. Увеличение тестового покрытия и уменьшение вероятности пропуска
ошибок.
4. Прогнозирование вероятности появления ошибок.
5. Применение Low-code подхода к тестированию.
Следует отметить, что ИИ в процессе тестирования применяют только боль-
шие ИТ-компании, потому что такой подход требует значительных затрат. Кроме
того, необходимо проводить дополнительное тестирование для проверки адекват-
ности полученных результатов.
Опросы разработчиков ПО на платформе Stackoverflow [4] показывает, что
почти все респонденты согласны с тем, что ИИ повлияет на их профессиональную
деятельность в ближайшее время. Примерно 75% опрошенных считают, что в
процессе тестирования появятся новые практики, связанные с применением ИИ.
1.
2.
3.
4.
Список источников
AI in Software Testing – Benefits, Approaches, Tools to Look in 2024 – URL:
https://www.testingxperts.com/blog/AI-in-Software-Testing (дата обращения:
29.09.2023).
Launchable URL: https://www.launchableinc.com/industry/computer-software
(дата обращения: 29.09.2023).
Exterman Dori The Future of Software Development URL: https://www.incredi-
build.com/blog/the-future-of-software-development
(дата
обращения:
29.09.2023).
Исследования по применению искусственного интеллекта на платформе
Stackoverflow URL: https://survey.stackoverflow.co/2023/#section-developer-
tools-ai-tools-next-year (дата обращения: 29.09.2023).10. ПРИМЕНЕНИЕ ИСКУССТВЕННОГО ИНТЕЛЛЕКТА
В ТЕСТИРОВАНИИ
10.2. Практическое применение ИИ в тестировании
Рассмотрим некоторые возможности ИИ в тестировании с использованием
инструментов, находящихся в свободном доступе и включенных в Единый реестр
российских программ для ЭВМ и БД.
Использование возможностей GigaChat в тестировании
Для обращения к нейросетевой модели GigaChat от Сбера воспользуемся бо-
том в телеграмме (https://t.me/gigachat_bot). Инструкция по составлению запросов
от GigaChat представлена ниже.
Напиши – я придумаю оригинальный текст.
Объясни – я расскажу сложное простыми словами.
Расскажи кратко – я вкратце перескажу текст.
Нарисуй – я создам картинку.
Иногда я плохо понимаю запросы, не сердитесь. Я всё ещё учусь. Когда я вырасту,
я стану самой умной AI-моделью.
В настоящее время к GigaChat обращаются:
– для генерации тестовых данных;
– для составления тестовых сценариев и чек-листов;
– с целью реализации тест-кейсов на основе техники тест-дизайна.
Например, на запрос о генерации тестовых данных по шаблону дан правиль-
ный ответ (рис.1, а). На уточняющий запрос о представлении данных в табличном
формате данные модифицированы и представлены в требуемом виде (рис.1, б).а)
Рисунок 1 – Запрос на генерацию тестовых данных
а) по текстовому шаблону
б) в табличном виде
Рисунок 2 – Запрос на создание чек-листа
б)Рисунок 3 – Запрос на создание отчета по дефекту
На запрос на разработку тест-кейсов по тестированию формы ввода в виде
HTML-кода GigaChat прочитал программный код, правильно выделил названия
классов (рис. 4) и сгенерировал тест-кейсы (рис. 5).
Рисунок 4 – Выделение названия классов и диагностика структуры HTML-кодаРисунок 5 – Тест-кейсы для тестирования техникой граничных значений
Также GigaChat успешно справился с составлением плана профессиональ-
ного развития для инженера по тестированию (рис.6).
На основании проведенных экспериментов можно сделать вывод, что в
настоящее время GigaChat понимает текстовые запросы и может корректно на них
отвечать. Для тестировщика он будет полезен для ускорения разработки тест-кей-
сов, чек-листов, тестового плана, окажет помощь в составлении плана тестирова-
ния, ответит на теоретические вопросы по тестированию. Однако результаты ра-
боты GigaChat требуют контроля со стороны квалифицированного тестировщика.а)
б)
Рисунок 6 – Запрос на составление плана профессионального развития
а) начало ответа
б) завершение ответа
Применение нейросетевой модели YandexGPT
YandexGPT – модель искусственного интеллекта, которая генерирует ответы
на запросы [1] подобно диалогу в мессенджере. Для запуска достаточно открыть
на компьютере стартовую страницу поисковой системы Яндекс и нажать на зна-
чок «YandexGPT» в нижнем правом углу, после чего откроется чат для общения.
Взаимодействовать с моделью можно также через голосовой интерфейс. Напри-
мер, на запрос: «Напиши чек-лист для тестирования формы ввода пароля»,
нейросеть предложила ответ, фрагмент которого представлен на рис.7.Рисунок 7 – Фрагмент ответа YandexGPT на запрос
В настоящий момент данная языковая модель обучается и совершенствуется.
1.
Список источников
Блог Я.Практикума Chat GPT по-русски: на что способна нейронка от Ян-
декса URL: https://practicum.yandex.ru/blog/neyroset-yandexgpt-kak-polzovat-
sya/ (дата обращения: 29.09.2023).
